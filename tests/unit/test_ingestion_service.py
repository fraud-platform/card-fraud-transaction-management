"""Unit tests for ingestion service."""

from datetime import datetime
from decimal import Decimal
from unittest.mock import AsyncMock, MagicMock
from uuid import UUID, uuid7

import pytest

from app.schemas.decision_event import (
    CardNetwork,
    DecisionEventCreate,
    DecisionReason,
    DecisionType,
    EvaluationType,
    IngestionSource,
    RuleMatch,
    TransactionDetails,
)
from app.services.ingestion_service import IngestionService


class TestIngestionService:
    """Test IngestionService class."""

    def test_service_creation(self):
        """Test creating IngestionService instance."""
        mock_session = MagicMock()
        service = IngestionService(mock_session)
        assert service.session == mock_session
        assert service.repository is not None
        assert service.review_repo is not None

    def test_service_has_ingest_event_method(self):
        """Test IngestionService has ingest_event method."""
        assert hasattr(IngestionService, "ingest_event")
        assert callable(IngestionService.ingest_event)


class TestIngestionServiceAsyncMethods:
    """Test IngestionService async methods."""

    def _create_test_event(self, with_rules=False):
        """Helper to create a test decision event."""
        details = TransactionDetails(
            card_id="tok_card123",
            card_last4="1234",
            card_network=CardNetwork.VISA,
            amount=Decimal("100.00"),
            currency="USD",
            country="US",
            merchant_id="merchant_001",
            mcc="5411",
        )

        matched_rules = []
        if with_rules:
            matched_rules = [
                RuleMatch(
                    rule_id="rule_001",
                    rule_version=1,
                    priority=10,
                    rule_name="Velocity Check",
                    rule_type="velocity",
                )
            ]

        return DecisionEventCreate(
            transaction_id="txn_test_001",
            occurred_at=datetime.now(),
            produced_at=datetime.now(),
            evaluation_type=EvaluationType.AUTH,
            transaction=details,
            decision=DecisionType.APPROVE,
            decision_reason=DecisionReason.DEFAULT_ALLOW,
            matched_rules=matched_rules,
        )

    @pytest.mark.asyncio
    async def test_ingest_event_returns_result(self):
        """Test ingest_event returns accepted result with generated UUID."""
        mock_session = MagicMock()
        service = IngestionService(mock_session)

        test_uuid = uuid7()
        transaction_data = {
            "id": str(uuid7()),
            "transaction_id": test_uuid,
            "card_id": "tok_card123",
            "amount": 100.00,
            "currency": "USD",
            "decision": "APPROVE",
            "decision_reason": "DEFAULT_ALLOW",
        }

        service.repository.upsert_transaction = AsyncMock(return_value=transaction_data)
        service.repository.add_rule_match = AsyncMock()
        service.review_repo.get_by_transaction_id = AsyncMock(
            return_value=None
        )  # No existing review
        service.review_repo.create = AsyncMock(return_value={"id": uuid7()})  # Mock created review

        event = self._create_test_event()

        result = await service.ingest_event(event=event)

        assert result is not None
        assert result["status"] == "accepted"
        # transaction_id is now a UUID generated by the service
        assert "transaction_id" in result
        assert isinstance(UUID(result["transaction_id"]), UUID)
        assert result["ingestion_source"] == "HTTP"

    @pytest.mark.asyncio
    async def test_ingest_event_with_trace_id(self):
        """Test ingest_event uses trace_id from request."""
        mock_session = MagicMock()
        service = IngestionService(mock_session)

        service.repository.upsert_transaction = AsyncMock(return_value={"id": str(uuid7())})
        service.repository.add_rule_match = AsyncMock()
        service.review_repo.get_by_transaction_id = AsyncMock(return_value=None)
        service.review_repo.create = AsyncMock(return_value={"id": uuid7()})

        event = self._create_test_event()

        await service.ingest_event(
            event=event,
            source=IngestionSource.HTTP,
            trace_id="custom-trace-id",
        )

        # Verify trace_id was passed
        call_args = service.repository.upsert_transaction.call_args[0][0]
        assert call_args["trace_id"] == "custom-trace-id"

    @pytest.mark.asyncio
    async def test_ingest_event_with_kafka_source(self):
        """Test ingest_event uses Kafka source."""
        mock_session = MagicMock()
        service = IngestionService(mock_session)

        service.repository.upsert_transaction = AsyncMock(return_value={"id": str(uuid7())})
        service.repository.add_rule_match = AsyncMock()
        service.review_repo.get_by_transaction_id = AsyncMock(return_value=None)
        service.review_repo.create = AsyncMock(return_value={"id": uuid7()})

        event = self._create_test_event()

        result = await service.ingest_event(
            event=event,
            source=IngestionSource.KAFKA,
        )

        assert result["ingestion_source"] == "KAFKA"

    @pytest.mark.asyncio
    async def test_ingest_event_with_matched_rules(self):
        """Test ingest_event processes matched rules."""
        mock_session = MagicMock()
        service = IngestionService(mock_session)

        service.repository.upsert_transaction = AsyncMock(return_value={"id": str(uuid7())})
        service.repository.add_rule_match = AsyncMock()
        service.review_repo.get_by_transaction_id = AsyncMock(return_value=None)
        service.review_repo.create = AsyncMock(return_value={"id": uuid7()})

        event = self._create_test_event(with_rules=True)

        await service.ingest_event(event=event)

        # Verify add_rule_match was called for each rule
        assert service.repository.add_rule_match.call_count == 1

    @pytest.mark.asyncio
    async def test_ingest_event_without_matched_rules(self):
        """Test ingest_event handles events without matched rules."""
        mock_session = MagicMock()
        service = IngestionService(mock_session)

        service.repository.upsert_transaction = AsyncMock(return_value={"id": str(uuid7())})
        service.repository.add_rule_match = AsyncMock()
        service.review_repo.get_by_transaction_id = AsyncMock(return_value=None)
        service.review_repo.create = AsyncMock(return_value={"id": uuid7()})

        event = self._create_test_event(with_rules=False)

        await service.ingest_event(event=event)

        # add_rule_match should not be called when no rules
        service.repository.add_rule_match.assert_not_called()

    @pytest.mark.asyncio
    async def test_ingest_event_maps_card_network(self):
        """Test ingest_event maps CardNetwork enum to value."""
        mock_session = MagicMock()
        service = IngestionService(mock_session)

        service.repository.upsert_transaction = AsyncMock(return_value={"id": str(uuid7())})
        service.repository.add_rule_match = AsyncMock()
        service.review_repo.get_by_transaction_id = AsyncMock(return_value=None)
        service.review_repo.create = AsyncMock(return_value={"id": uuid7()})

        event = self._create_test_event()

        await service.ingest_event(event=event)

        call_args = service.repository.upsert_transaction.call_args[0][0]
        assert call_args["card_network"] == "VISA"

    @pytest.mark.asyncio
    async def test_ingest_event_handles_none_card_network(self):
        """Test ingest_event handles None card_network."""
        mock_session = MagicMock()
        service = IngestionService(mock_session)

        details = TransactionDetails(
            card_id="tok_card456",
            amount=Decimal("50.00"),
            currency="USD",
            country="US",
            # No card_network
        )
        event = DecisionEventCreate(
            transaction_id="txn_no_network",
            occurred_at=datetime.now(),
            produced_at=datetime.now(),
            evaluation_type=EvaluationType.AUTH,
            transaction=details,
            decision=DecisionType.DECLINE,
            decision_reason=DecisionReason.RULE_MATCH,
        )

        service.repository.upsert_transaction = AsyncMock(return_value={"id": str(uuid7())})
        service.repository.add_rule_match = AsyncMock()
        service.review_repo.get_by_transaction_id = AsyncMock(return_value=None)
        service.review_repo.create = AsyncMock(return_value={"id": uuid7()})

        await service.ingest_event(event=event)

        call_args = service.repository.upsert_transaction.call_args[0][0]
        assert call_args["card_network"] is None

    @pytest.mark.asyncio
    async def test_ingest_event_maps_decision_enums(self):
        """Test ingest_event maps decision enums to values."""
        mock_session = MagicMock()
        service = IngestionService(mock_session)

        service.repository.upsert_transaction = AsyncMock(return_value={})
        service.repository.add_rule_match = AsyncMock()
        service.review_repo.get_by_transaction_id = AsyncMock(return_value=None)
        service.review_repo.create = AsyncMock(return_value={"id": uuid7()})

        event = self._create_test_event()
        event.decision = DecisionType.DECLINE
        event.decision_reason = DecisionReason.RULE_MATCH

        await service.ingest_event(event=event)

        call_args = service.repository.upsert_transaction.call_args[0][0]
        assert call_args["decision"] == "DECLINE"
        assert call_args["decision_reason"] == "RULE_MATCH"


class TestIngestionServiceMethodSignatures:
    """Test IngestionService method signatures."""

    @pytest.mark.asyncio
    async def test_ingest_event_is_async(self):
        """Test ingest_event is an async coroutine function."""
        import inspect

        assert inspect.iscoroutinefunction(IngestionService.ingest_event)

    @pytest.mark.asyncio
    async def test_ingest_event_accepts_parameters(self):
        """Test ingest_event accepts required parameters."""
        import inspect

        sig = inspect.signature(IngestionService.ingest_event)
        params = list(sig.parameters.keys())
        assert "self" in params
        assert "event" in params
        assert "source" in params


class TestIngestionServiceRepositoryIntegration:
    """Test IngestionService integrates with repository."""

    def test_service_creates_repository_instances(self):
        """Test service creates repository instances."""
        mock_session = MagicMock()
        service = IngestionService(mock_session)
        from app.persistence.review_repository import ReviewRepository
        from app.persistence.transaction_repository import TransactionRepository

        assert isinstance(service.repository, TransactionRepository)
        assert isinstance(service.review_repo, ReviewRepository)

    def test_service_uses_same_session(self):
        """Test service uses same session for repositories."""
        mock_session = MagicMock()
        service = IngestionService(mock_session)
        assert service.session is mock_session

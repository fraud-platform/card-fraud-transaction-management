"""Unit tests for services."""

from typing import Any
from unittest.mock import AsyncMock, patch
from uuid import UUID, uuid4, uuid7

import pytest

from app.core.errors import ConflictError, NotFoundError, ValidationError
from app.schemas.decision_event import DecisionEventCreate, IngestionSource
from app.services.case_service import CaseService
from app.services.ingestion_service import IngestionService
from app.services.review_service import ReviewService
from app.services.transaction_service import TransactionService


class TestIngestionService:
    """Tests for IngestionService."""

    @pytest.mark.asyncio
    async def test_ingest_event_creates_transaction(
        self, sample_decision_event: DecisionEventCreate, mock_session: AsyncMock
    ):
        """Test that ingesting an event creates a transaction with generated UUID."""
        # Mock the repository's upsert_transaction to return the created transaction
        # The service now generates a UUID for transaction_id
        generated_uuid = uuid7()
        mock_repository = AsyncMock()
        mock_repository.upsert_transaction = AsyncMock(
            return_value={
                "id": str(generated_uuid),
                "transaction_id": generated_uuid,
            }
        )
        mock_repository.add_rule_match = AsyncMock()
        mock_review_repo = AsyncMock()
        mock_review_repo.get_by_transaction_id = AsyncMock(return_value=None)
        mock_review_repo.create = AsyncMock(return_value={"id": uuid7()})

        with patch.object(
            IngestionService,
            "__init__",
            lambda self, session: None,
        ):
            service = IngestionService(mock_session)
            service.repository = mock_repository
            service.review_repo = mock_review_repo

            result = await service.ingest_event(
                event=sample_decision_event,
                source=IngestionSource.HTTP,
                trace_id="trace_123",
            )

            assert result["status"] == "accepted"
            assert result["ingestion_source"] == "HTTP"
            # transaction_id is now a UUID generated by the service
            assert "transaction_id" in result
            # Should be a valid UUID string
            assert isinstance(UUID(result["transaction_id"]), UUID)

    @pytest.mark.asyncio
    async def test_ingest_event_with_rules(
        self, sample_decision_event: DecisionEventCreate, mock_session: AsyncMock
    ):
        """Test that ingesting an event with rules adds rule matches."""
        mock_repository = AsyncMock()
        mock_repository.upsert_transaction = AsyncMock(
            return_value={
                "id": str(uuid7()),
                "transaction_id": uuid7(),
            }
        )
        mock_repository.add_rule_match = AsyncMock()
        mock_review_repo = AsyncMock()
        mock_review_repo.get_by_transaction_id = AsyncMock(return_value=None)
        mock_review_repo.create = AsyncMock(return_value={"id": uuid7()})

        with patch.object(
            IngestionService,
            "__init__",
            lambda self, session: None,
        ):
            service = IngestionService(mock_session)
            service.repository = mock_repository
            service.review_repo = mock_review_repo

            await service.ingest_event(
                event=sample_decision_event,
                source=IngestionSource.KAFKA,
            )

            # Verify add_rule_match was called for each rule
            assert mock_repository.add_rule_match.call_count == len(
                sample_decision_event.matched_rules
            )

    @pytest.mark.asyncio
    async def test_ingest_event_idempotent(
        self, sample_decision_event: DecisionEventCreate, mock_session: AsyncMock
    ):
        """Test that ingesting the same event twice works correctly (idempotent at DB level)."""
        # In the new schema, each ingestion generates a new UUID for transaction_id
        # Idempotency is handled at the database level via upsert
        mock_repository = AsyncMock()

        # Each call to upsert_transaction returns a different UUID
        # (this simulates the behavior of generating new IDs)
        call_count = 0

        def mock_upsert(*args: Any, **kwargs: Any) -> dict[str, Any]:
            nonlocal call_count
            call_count += 1
            return {
                "id": str(uuid7()),
                "transaction_id": uuid7(),
            }

        mock_repository.upsert_transaction = AsyncMock(side_effect=mock_upsert)
        mock_review_repo = AsyncMock()
        mock_review_repo.get_by_transaction_id = AsyncMock(return_value=None)
        mock_review_repo.create = AsyncMock(return_value={"id": uuid7()})

        with patch.object(
            IngestionService,
            "__init__",
            lambda self, session: None,
        ):
            service = IngestionService(mock_session)
            service.repository = mock_repository
            service.review_repo = mock_review_repo

            # First ingestion
            result1 = await service.ingest_event(
                event=sample_decision_event,
                source=IngestionSource.HTTP,
            )

            # Second ingestion with same event data
            result2 = await service.ingest_event(
                event=sample_decision_event,
                source=IngestionSource.HTTP,
            )

            # Both calls succeed
            assert result1["status"] == result2["status"] == "accepted"
            assert "transaction_id" in result1
            assert "transaction_id" in result2
            # upsert_transaction is called twice (idempotency is handled at DB level)
            assert mock_repository.upsert_transaction.call_count == 2


class TestTransactionService:
    """Tests for TransactionService."""

    @pytest.mark.asyncio
    async def test_list_transactions_pagination(self, mock_session: AsyncMock):
        """Test that list_transactions returns paginated results with keyset pagination."""
        mock_repository = AsyncMock()
        mock_repository.list = AsyncMock(
            return_value=(
                [
                    {"transaction_id": uuid7(), "card_id": "tok_1", "amount": 100.00},
                    {"transaction_id": uuid7(), "card_id": "tok_2", "amount": 200.00},
                ],
                "next_cursor_abc",  # next_cursor
                10,  # total
            )
        )

        with patch.object(
            TransactionService,
            "__init__",
            lambda self, session: setattr(self, "repository", mock_repository),
        ):
            service = TransactionService(mock_session)
            service.repository = mock_repository

            result = await service.list_transactions(page_size=2, cursor=None)

            assert result["page_size"] == 2
            assert result["total"] == 10
            assert result["next_cursor"] == "next_cursor_abc"
            assert len(result["items"]) == 2

    @pytest.mark.asyncio
    async def test_get_transaction_not_found(self, mock_session):
        """Test that get_transaction returns None for non-existent transaction."""
        mock_repository = AsyncMock()
        mock_repository.get_by_transaction_id = AsyncMock(return_value=None)

        with patch.object(
            TransactionService,
            "__init__",
            lambda self, session: setattr(self, "repository", mock_repository),
        ):
            service = TransactionService(mock_session)
            service.repository = mock_repository

            result = await service.get_transaction(uuid7())

            assert result is None

    @pytest.mark.asyncio
    async def test_get_metrics(self, mock_session):
        """Test getting transaction metrics."""
        mock_repository = AsyncMock()
        mock_repository.get_metrics = AsyncMock(
            return_value={
                "total_transactions": 100,
                "approved_count": 60,
                "declined_count": 30,
                "postauth_count": 10,
                "total_amount": 5000.00,
                "avg_amount": 50.00,
            }
        )

        with patch.object(
            TransactionService,
            "__init__",
            lambda self, session: setattr(self, "repository", mock_repository),
        ):
            service = TransactionService(mock_session)
            service.repository = mock_repository

            result = await service.get_metrics()

            assert result["total_transactions"] == 100
            assert result["approved_count"] == 60


class TestBulkOperationsService:
    """Tests for BulkOperationsService."""

    @pytest.fixture
    def sample_review(self):
        """Sample review dict for testing."""
        return {
            "id": uuid7(),
            "transaction_id": uuid7(),
            "status": "PENDING",
            "priority": 3,
            "assigned_analyst_id": None,
            "assigned_at": None,
            "case_id": None,
            "resolved_at": None,
            "resolved_by": None,
            "resolution_code": None,
            "resolution_notes": None,
            "escalated_at": None,
            "escalated_to": None,
            "escalation_reason": None,
            "first_reviewed_at": None,
            "last_activity_at": None,
            "created_at": None,
            "updated_at": None,
        }

    # ==================== bulk_assign tests ====================

    @pytest.mark.asyncio
    async def test_bulk_assign_success(self, mock_session, sample_review):
        """Test successful bulk assignment of transactions."""
        from app.services.bulk_operations_service import BulkOperationsService

        transaction_ids = [uuid7(), uuid7(), uuid7()]
        analyst_id = "analyst_123"

        mock_review_repo = AsyncMock()
        mock_review_repo.get_by_transaction_id = AsyncMock(return_value=sample_review)
        mock_review_repo.assign = AsyncMock(return_value=sample_review)

        with patch.object(
            BulkOperationsService,
            "__init__",
            lambda self, session: None,
        ):
            service = BulkOperationsService(mock_session)
            service.review_repo = mock_review_repo

            result = await service.bulk_assign(transaction_ids, analyst_id)

            assert result["total_requested"] == 3
            assert result["successful"] == 3
            assert result["failed"] == 0
            assert result["error_summary"] is None
            assert len(result["results"]) == 3
            assert all(r["success"] for r in result["results"])
            assert mock_review_repo.assign.call_count == 3

    @pytest.mark.asyncio
    async def test_bulk_assign_empty_list(self, mock_session):
        """Test bulk assign with empty transaction list."""
        from app.services.bulk_operations_service import BulkOperationsService

        mock_review_repo = AsyncMock()

        with patch.object(
            BulkOperationsService,
            "__init__",
            lambda self, session: None,
        ):
            service = BulkOperationsService(mock_session)
            service.review_repo = mock_review_repo

            result = await service.bulk_assign([], "analyst_123")

            assert result["total_requested"] == 0
            assert result["successful"] == 0
            assert result["failed"] == 0
            assert result["results"] == []
            assert result["error_summary"] is None

    @pytest.mark.asyncio
    async def test_bulk_assign_non_existent_transactions(self, mock_session):
        """Test bulk assign with non-existent transactions."""
        from app.services.bulk_operations_service import BulkOperationsService

        transaction_ids = [uuid7(), uuid7(), uuid7()]
        analyst_id = "analyst_123"

        mock_review_repo = AsyncMock()
        mock_review_repo.get_by_transaction_id = AsyncMock(return_value=None)

        with patch.object(
            BulkOperationsService,
            "__init__",
            lambda self, session: None,
        ):
            service = BulkOperationsService(mock_session)
            service.review_repo = mock_review_repo

            result = await service.bulk_assign(transaction_ids, analyst_id)

            assert result["total_requested"] == 3
            assert result["successful"] == 0
            assert result["failed"] == 3
            assert result["error_summary"] == {"REVIEW_NOT_FOUND": 3}
            assert len(result["results"]) == 3
            assert all(not r["success"] for r in result["results"])
            assert all(r["error_code"] == "REVIEW_NOT_FOUND" for r in result["results"])

    @pytest.mark.asyncio
    async def test_bulk_assign_mixed_success_and_failure(self, mock_session, sample_review):
        """Test bulk assign with some transactions existing and some not."""
        from app.services.bulk_operations_service import BulkOperationsService

        transaction_ids = [uuid7(), uuid7(), uuid7()]
        analyst_id = "analyst_123"

        call_count = 0

        def mock_get_transaction(*args: Any, **kwargs: Any) -> Any:
            nonlocal call_count
            call_count += 1
            # First and third transactions exist, second doesn't
            if call_count in [1, 3]:
                return sample_review
            return None

        mock_review_repo = AsyncMock()
        mock_review_repo.get_by_transaction_id = AsyncMock(side_effect=mock_get_transaction)
        mock_review_repo.assign = AsyncMock(return_value=sample_review)

        with patch.object(
            BulkOperationsService,
            "__init__",
            lambda self, session: None,
        ):
            service = BulkOperationsService(mock_session)
            service.review_repo = mock_review_repo

            result = await service.bulk_assign(transaction_ids, analyst_id)

            assert result["total_requested"] == 3
            assert result["successful"] == 2
            assert result["failed"] == 1
            assert result["error_summary"] == {"REVIEW_NOT_FOUND": 1}
            assert mock_review_repo.assign.call_count == 2

    @pytest.mark.asyncio
    async def test_bulk_assign_database_error(self, mock_session, sample_review):
        """Test bulk assign when database operation fails."""
        from app.services.bulk_operations_service import BulkOperationsService

        transaction_ids = [uuid7(), uuid7()]
        analyst_id = "analyst_123"

        mock_review_repo = AsyncMock()
        mock_review_repo.get_by_transaction_id = AsyncMock(return_value=sample_review)
        mock_review_repo.assign = AsyncMock(side_effect=Exception("Database connection failed"))

        with patch.object(
            BulkOperationsService,
            "__init__",
            lambda self, session: None,
        ):
            service = BulkOperationsService(mock_session)
            service.review_repo = mock_review_repo

            result = await service.bulk_assign(transaction_ids, analyst_id)

            assert result["total_requested"] == 2
            assert result["successful"] == 0
            assert result["failed"] == 2
            assert result["error_summary"] == {"ASSIGNMENT_ERROR": 2}
            assert all(not r["success"] for r in result["results"])
            assert all(r["error_code"] == "ASSIGNMENT_ERROR" for r in result["results"])

    @pytest.mark.asyncio
    async def test_bulk_assign_large_batch(self, mock_session, sample_review):
        """Test bulk assign with large batch (100 items)."""
        from app.services.bulk_operations_service import BulkOperationsService

        transaction_ids = [uuid7() for _ in range(100)]
        analyst_id = "analyst_123"

        mock_review_repo = AsyncMock()
        mock_review_repo.get_by_transaction_id = AsyncMock(return_value=sample_review)
        mock_review_repo.assign = AsyncMock(return_value=sample_review)

        with patch.object(
            BulkOperationsService,
            "__init__",
            lambda self, session: None,
        ):
            service = BulkOperationsService(mock_session)
            service.review_repo = mock_review_repo

            result = await service.bulk_assign(transaction_ids, analyst_id)

            assert result["total_requested"] == 100
            assert result["successful"] == 100
            assert result["failed"] == 0
            assert mock_review_repo.assign.call_count == 100

    # ==================== bulk_update_status tests ====================

    @pytest.mark.asyncio
    async def test_bulk_update_status_success(self, mock_session, sample_review):
        """Test successful bulk status update."""
        from app.services.bulk_operations_service import BulkOperationsService

        transaction_ids = [uuid7(), uuid7(), uuid7()]
        status = "RESOLVED"
        resolution_code = "LEGITIMATE"
        resolution_notes = "Verified with customer"
        resolved_by = "analyst_123"

        mock_review_repo = AsyncMock()
        mock_review_repo.get_by_transaction_id = AsyncMock(return_value=sample_review)
        mock_review_repo.update_status = AsyncMock(return_value=sample_review)

        with patch.object(
            BulkOperationsService,
            "__init__",
            lambda self, session: None,
        ):
            service = BulkOperationsService(mock_session)
            service.review_repo = mock_review_repo

            result = await service.bulk_update_status(
                transaction_ids=transaction_ids,
                status=status,
                resolution_code=resolution_code,
                resolution_notes=resolution_notes,
                resolved_by=resolved_by,
            )

            assert result["total_requested"] == 3
            assert result["successful"] == 3
            assert result["failed"] == 0
            assert mock_review_repo.update_status.call_count == 3

    @pytest.mark.asyncio
    async def test_bulk_update_status_invalid_status(self, mock_session, sample_review):
        """Test bulk update with invalid status (still passed to repo)."""
        from app.services.bulk_operations_service import BulkOperationsService

        transaction_ids = [uuid7()]
        invalid_status = "INVALID_STATUS"

        mock_review_repo = AsyncMock()
        mock_review_repo.get_by_transaction_id = AsyncMock(return_value=sample_review)
        mock_review_repo.update_status = AsyncMock(return_value=sample_review)

        with patch.object(
            BulkOperationsService,
            "__init__",
            lambda self, session: None,
        ):
            service = BulkOperationsService(mock_session)
            service.review_repo = mock_review_repo

            # Service doesn't validate status, it passes to repository
            result = await service.bulk_update_status(
                transaction_ids=transaction_ids,
                status=invalid_status,
            )

            # The service layer doesn't validate, so it succeeds
            assert result["successful"] == 1
            assert mock_review_repo.update_status.call_count == 1

    @pytest.mark.asyncio
    async def test_bulk_update_status_with_non_existent(self, mock_session, sample_review):
        """Test bulk update status with non-existent transactions."""
        from app.services.bulk_operations_service import BulkOperationsService

        transaction_ids = [uuid7(), uuid7(), uuid7()]

        mock_review_repo = AsyncMock()
        mock_review_repo.get_by_transaction_id = AsyncMock(return_value=None)

        with patch.object(
            BulkOperationsService,
            "__init__",
            lambda self, session: None,
        ):
            service = BulkOperationsService(mock_session)
            service.review_repo = mock_review_repo

            result = await service.bulk_update_status(
                transaction_ids=transaction_ids,
                status="RESOLVED",
            )

            assert result["total_requested"] == 3
            assert result["successful"] == 0
            assert result["failed"] == 3
            assert result["error_summary"] == {"REVIEW_NOT_FOUND": 3}

    @pytest.mark.asyncio
    async def test_bulk_update_status_database_error(self, mock_session, sample_review):
        """Test bulk update status when database operation fails."""
        from app.services.bulk_operations_service import BulkOperationsService

        transaction_ids = [uuid7(), uuid7()]

        mock_review_repo = AsyncMock()
        mock_review_repo.get_by_transaction_id = AsyncMock(return_value=sample_review)
        mock_review_repo.update_status = AsyncMock(side_effect=Exception("Database error"))

        with patch.object(
            BulkOperationsService,
            "__init__",
            lambda self, session: None,
        ):
            service = BulkOperationsService(mock_session)
            service.review_repo = mock_review_repo

            result = await service.bulk_update_status(
                transaction_ids=transaction_ids,
                status="RESOLVED",
            )

            assert result["total_requested"] == 2
            assert result["successful"] == 0
            assert result["failed"] == 2
            assert result["error_summary"] == {"STATUS_UPDATE_ERROR": 2}

    @pytest.mark.asyncio
    async def test_bulk_update_status_large_batch(self, mock_session, sample_review):
        """Test bulk update status with large batch (100 items)."""
        from app.services.bulk_operations_service import BulkOperationsService

        transaction_ids = [uuid7() for _ in range(100)]

        mock_review_repo = AsyncMock()
        mock_review_repo.get_by_transaction_id = AsyncMock(return_value=sample_review)
        mock_review_repo.update_status = AsyncMock(return_value=sample_review)

        with patch.object(
            BulkOperationsService,
            "__init__",
            lambda self, session: None,
        ):
            service = BulkOperationsService(mock_session)
            service.review_repo = mock_review_repo

            result = await service.bulk_update_status(
                transaction_ids=transaction_ids,
                status="IN_REVIEW",
            )

            assert result["total_requested"] == 100
            assert result["successful"] == 100
            assert mock_review_repo.update_status.call_count == 100

    # ==================== bulk_create_case tests ====================

    @pytest.mark.asyncio
    async def test_bulk_create_case_success(self, mock_session):
        """Test successful bulk case creation."""
        from app.services.bulk_operations_service import BulkOperationsService

        transaction_ids = [uuid7(), uuid7(), uuid7()]
        case_type = "FRAUD_INVESTIGATION"
        title = "Test Case"
        description = "Test description"
        assigned_analyst_id = "analyst_123"
        risk_level = "HIGH"

        mock_case_repo = AsyncMock()
        mock_case_repo.generate_case_number = AsyncMock(return_value="CASE-001")
        mock_case_repo.create = AsyncMock(return_value={"id": uuid7()})
        mock_case_repo.log_activity = AsyncMock(return_value={"id": uuid7()})

        with patch.object(
            BulkOperationsService,
            "__init__",
            lambda self, session: None,
        ):
            service = BulkOperationsService(mock_session)
            service.case_repo = mock_case_repo

            result = await service.bulk_create_case(
                transaction_ids=transaction_ids,
                case_type=case_type,
                title=title,
                description=description,
                assigned_analyst_id=assigned_analyst_id,
                risk_level=risk_level,
                analyst_id="analyst_123",
                analyst_name="Test Analyst",
            )

            assert result["total_requested"] == 3
            assert result["successful"] == 3
            assert result["failed"] == 0
            assert result["error_summary"] is None
            assert "created_case_id" in result
            assert result["created_case_number"] == "CASE-001"
            assert mock_case_repo.create.call_count == 1
            assert mock_case_repo.log_activity.call_count == 1

    @pytest.mark.asyncio
    async def test_bulk_create_case_missing_title(self, mock_session):
        """Test bulk create case with missing title."""
        from app.services.bulk_operations_service import BulkOperationsService

        transaction_ids = [uuid7()]

        with patch.object(
            BulkOperationsService,
            "__init__",
            lambda self, session: None,
        ):
            service = BulkOperationsService(mock_session)

            with pytest.raises(ValidationError) as exc_info:
                await service.bulk_create_case(
                    transaction_ids=transaction_ids,
                    case_type="FRAUD_INVESTIGATION",
                    title="",
                )

            assert "Case title is required" in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_bulk_create_case_whitespace_only_title(self, mock_session):
        """Test bulk create case with whitespace-only title."""
        from app.services.bulk_operations_service import BulkOperationsService

        transaction_ids = [uuid7()]

        with patch.object(
            BulkOperationsService,
            "__init__",
            lambda self, session: None,
        ):
            service = BulkOperationsService(mock_session)

            with pytest.raises(ValidationError) as exc_info:
                await service.bulk_create_case(
                    transaction_ids=transaction_ids,
                    case_type="FRAUD_INVESTIGATION",
                    title="   ",
                )

            assert "Case title is required" in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_bulk_create_case_empty_transaction_list(self, mock_session):
        """Test bulk create case with empty transaction list."""
        from app.services.bulk_operations_service import BulkOperationsService

        mock_case_repo = AsyncMock()
        mock_case_repo.generate_case_number = AsyncMock(return_value="CASE-001")
        mock_case_repo.create = AsyncMock(return_value={"id": uuid7()})
        mock_case_repo.log_activity = AsyncMock(return_value={"id": uuid7()})

        with patch.object(
            BulkOperationsService,
            "__init__",
            lambda self, session: None,
        ):
            service = BulkOperationsService(mock_session)
            service.case_repo = mock_case_repo

            result = await service.bulk_create_case(
                transaction_ids=[],
                case_type="FRAUD_INVESTIGATION",
                title="Empty Case",
            )

            assert result["total_requested"] == 0
            assert result["successful"] == 0
            assert result["failed"] == 0
            assert result["results"] == []

    @pytest.mark.asyncio
    async def test_bulk_create_case_database_error_on_create(self, mock_session):
        """Test bulk create case when database create fails."""
        from app.services.bulk_operations_service import BulkOperationsService

        transaction_ids = [uuid7(), uuid7()]

        mock_case_repo = AsyncMock()
        mock_case_repo.generate_case_number = AsyncMock(return_value="CASE-001")
        mock_case_repo.create = AsyncMock(side_effect=Exception("Database connection failed"))

        with patch.object(
            BulkOperationsService,
            "__init__",
            lambda self, session: None,
        ):
            service = BulkOperationsService(mock_session)
            service.case_repo = mock_case_repo

            with pytest.raises(Exception, match="Database connection failed"):
                await service.bulk_create_case(
                    transaction_ids=transaction_ids,
                    case_type="FRAUD_INVESTIGATION",
                    title="Test Case",
                )

    @pytest.mark.asyncio
    async def test_bulk_create_case_database_error_on_log_activity(self, mock_session):
        """Test bulk create case when activity logging fails."""
        from app.services.bulk_operations_service import BulkOperationsService

        transaction_ids = [uuid7()]

        mock_case_repo = AsyncMock()
        mock_case_repo.generate_case_number = AsyncMock(return_value="CASE-001")
        mock_case_repo.create = AsyncMock(return_value={"id": uuid7()})
        mock_case_repo.log_activity = AsyncMock(side_effect=Exception("Logging failed"))

        with patch.object(
            BulkOperationsService,
            "__init__",
            lambda self, session: None,
        ):
            service = BulkOperationsService(mock_session)
            service.case_repo = mock_case_repo

            with pytest.raises(Exception, match="Logging failed"):
                await service.bulk_create_case(
                    transaction_ids=transaction_ids,
                    case_type="FRAUD_INVESTIGATION",
                    title="Test Case",
                    analyst_id="analyst_123",
                    analyst_name="Test Analyst",
                )

    @pytest.mark.asyncio
    async def test_bulk_create_case_large_batch(self, mock_session):
        """Test bulk create case with large batch (100 items)."""
        from app.services.bulk_operations_service import BulkOperationsService

        transaction_ids = [uuid7() for _ in range(100)]

        mock_case_repo = AsyncMock()
        mock_case_repo.generate_case_number = AsyncMock(return_value="CASE-100")
        mock_case_repo.create = AsyncMock(return_value={"id": uuid7()})
        mock_case_repo.log_activity = AsyncMock(return_value={"id": uuid7()})

        with patch.object(
            BulkOperationsService,
            "__init__",
            lambda self, session: None,
        ):
            service = BulkOperationsService(mock_session)
            service.case_repo = mock_case_repo

            result = await service.bulk_create_case(
                transaction_ids=transaction_ids,
                case_type="FRAUD_INVESTIGATION",
                title="Large Batch Case",
            )

            assert result["total_requested"] == 100
            assert result["successful"] == 100
            assert result["failed"] == 0

    @pytest.mark.asyncio
    async def test_bulk_create_case_with_missing_optional_fields(self, mock_session):
        """Test bulk create case with only required fields."""
        from app.services.bulk_operations_service import BulkOperationsService

        transaction_ids = [uuid7()]

        mock_case_repo = AsyncMock()
        mock_case_repo.generate_case_number = AsyncMock(return_value="CASE-001")
        mock_case_repo.create = AsyncMock(return_value={"id": uuid7()})
        mock_case_repo.log_activity = AsyncMock(return_value={"id": uuid7()})

        with patch.object(
            BulkOperationsService,
            "__init__",
            lambda self, session: None,
        ):
            service = BulkOperationsService(mock_session)
            service.case_repo = mock_case_repo

            result = await service.bulk_create_case(
                transaction_ids=transaction_ids,
                case_type="FRAUD_INVESTIGATION",
                title="Minimal Case",
            )

            assert result["successful"] == 1
            assert mock_case_repo.create.call_count == 1

    # ==================== BulkOperationResult tests ====================

    def test_bulk_operation_result_to_dict_success(self):
        """Test BulkOperationResult to_dict for successful operation."""
        from app.services.bulk_operations_service import BulkOperationResult

        result = BulkOperationResult(
            transaction_id=uuid7(),
            success=True,
        )

        result_dict = result.to_dict()

        assert result_dict["success"] is True
        assert result_dict["error_message"] is None
        assert result_dict["error_code"] is None
        assert "transaction_id" in result_dict

    def test_bulk_operation_result_to_dict_failure(self):
        """Test BulkOperationResult to_dict for failed operation."""
        from app.services.bulk_operations_service import BulkOperationResult

        result = BulkOperationResult(
            transaction_id=uuid7(),
            success=False,
            error_message="Review not found",
            error_code="REVIEW_NOT_FOUND",
        )

        result_dict = result.to_dict()

        assert result_dict["success"] is False
        assert result_dict["error_message"] == "Review not found"
        assert result_dict["error_code"] == "REVIEW_NOT_FOUND"
        assert "transaction_id" in result_dict


class TestReviewService:
    """Tests for ReviewService."""

    # Helper method to create a mock review
    def _make_mock_review(self, review_id=None, status="PENDING", **kwargs):
        """Create a mock review dict with default values."""
        review_id = review_id or uuid4()
        return {
            "id": review_id,
            "transaction_id": uuid4(),
            "status": status,
            "priority": 3,
            "assigned_analyst_id": None,
            "assigned_at": None,
            "case_id": None,
            "resolved_at": None,
            "resolved_by": None,
            "resolution_code": None,
            "resolution_notes": None,
            "escalated_at": None,
            "escalated_to": None,
            "escalation_reason": None,
            "first_reviewed_at": None,
            "last_activity_at": None,
            "created_at": None,
            "updated_at": None,
            "transaction_amount": None,
            "transaction_currency": None,
            "decision": None,
            "risk_level": None,
            **kwargs,
        }

    @pytest.mark.asyncio
    async def test_get_review_success(self, mock_session):
        """Test getting a review by ID successfully."""
        review_id = uuid4()
        mock_review = self._make_mock_review(review_id=review_id)

        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(return_value=mock_review)

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)
            result = await service.get_review(review_id)

            assert result["id"] == review_id
            mock_repo.get_by_id.assert_called_once_with(review_id)

    @pytest.mark.asyncio
    async def test_get_review_not_found(self, mock_session):
        """Test getting a non-existent review raises NotFoundError."""
        review_id = uuid4()

        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(return_value=None)

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)

            with pytest.raises(NotFoundError) as exc_info:
                await service.get_review(review_id)

            assert "Review not found" in str(exc_info.value)
            assert exc_info.value.details["review_id"] == str(review_id)

    @pytest.mark.asyncio
    async def test_get_review_by_transaction_exists(self, mock_session):
        """Test getting review by transaction ID when it exists."""
        transaction_id = uuid4()
        mock_review = self._make_mock_review(transaction_id=transaction_id)

        mock_repo = AsyncMock()
        mock_repo.get_by_transaction_id = AsyncMock(return_value=mock_review)

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)
            result = await service.get_review_by_transaction(transaction_id)

            assert result["transaction_id"] == transaction_id
            mock_repo.get_by_transaction_id.assert_called_once_with(transaction_id)
            # Should not call create since review exists
            mock_repo.create.assert_not_called()

    @pytest.mark.asyncio
    async def test_get_review_by_transaction_auto_creates(self, mock_session):
        """Test that get_review_by_transaction auto-creates if not exists."""
        transaction_id = uuid4()
        new_review_id = uuid4()
        mock_new_review = self._make_mock_review(
            review_id=new_review_id, transaction_id=transaction_id
        )

        mock_repo = AsyncMock()
        mock_repo.get_by_transaction_id = AsyncMock(return_value=None)
        mock_repo.create = AsyncMock(return_value=mock_new_review)

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)
            result = await service.get_review_by_transaction(transaction_id)

            assert result["id"] == new_review_id
            mock_repo.get_by_transaction_id.assert_called_once_with(transaction_id)
            mock_repo.create.assert_called_once()

    @pytest.mark.asyncio
    async def test_create_review_success(self, mock_session):
        """Test creating a new review successfully."""
        transaction_id = uuid4()
        new_review_id = uuid4()
        mock_review = self._make_mock_review(
            review_id=new_review_id, transaction_id=transaction_id, priority=1
        )

        mock_repo = AsyncMock()
        mock_repo.get_by_transaction_id = AsyncMock(return_value=None)
        mock_repo.create = AsyncMock(return_value=mock_review)

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)
            result = await service.create_review(transaction_id, priority=1)

            assert result["id"] == new_review_id
            assert result["priority"] == 1
            mock_repo.create.assert_called_once()

    @pytest.mark.asyncio
    async def test_create_review_already_exists(self, mock_session):
        """Test creating a review when one already exists raises ConflictError."""
        transaction_id = uuid4()
        existing_review_id = uuid4()
        existing_review = self._make_mock_review(
            review_id=existing_review_id, transaction_id=transaction_id
        )

        mock_repo = AsyncMock()
        mock_repo.get_by_transaction_id = AsyncMock(return_value=existing_review)

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)

            with pytest.raises(ConflictError) as exc_info:
                await service.create_review(transaction_id)

            assert "Review already exists" in str(exc_info.value)
            assert exc_info.value.details["transaction_id"] == str(transaction_id)
            assert exc_info.value.details["existing_review_id"] == str(existing_review_id)

    @pytest.mark.asyncio
    async def test_update_status_valid_transition(self, mock_session):
        """Test updating status with a valid transition."""
        review_id = uuid4()
        mock_review = self._make_mock_review(review_id=review_id, status="PENDING")
        updated_review = self._make_mock_review(review_id=review_id, status="IN_REVIEW")

        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(return_value=mock_review)
        mock_repo.update_status = AsyncMock(return_value=updated_review)

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)
            result = await service.update_status(review_id, "IN_REVIEW")

            assert result["status"] == "IN_REVIEW"
            mock_repo.update_status.assert_called_once_with(
                review_id=review_id,
                status="IN_REVIEW",
                resolution_code=None,
                resolution_notes=None,
                resolved_by=None,
            )

    @pytest.mark.asyncio
    async def test_update_status_invalid_transition(self, mock_session):
        """Test that invalid status transitions raise ValidationError."""
        review_id = uuid4()
        mock_review = self._make_mock_review(review_id=review_id, status="CLOSED")

        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(return_value=mock_review)

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)

            with pytest.raises(ValidationError) as exc_info:
                await service.update_status(review_id, "PENDING")

            assert "Invalid status transition" in str(exc_info.value)
            assert exc_info.value.details["current_status"] == "CLOSED"
            assert exc_info.value.details["requested_status"] == "PENDING"

    @pytest.mark.asyncio
    async def test_update_status_resolved_without_notes(self, mock_session):
        """Test that resolving without notes raises ValidationError."""
        review_id = uuid4()
        mock_review = self._make_mock_review(review_id=review_id, status="IN_REVIEW")

        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(return_value=mock_review)

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)

            with pytest.raises(ValidationError) as exc_info:
                await service.update_status(review_id, "RESOLVED")

            assert "Resolution notes are required" in str(exc_info.value)
            assert exc_info.value.details["status"] == "RESOLVED"

    @pytest.mark.asyncio
    async def test_update_status_closed_without_notes(self, mock_session):
        """Test that closing without notes raises ValidationError."""
        review_id = uuid4()
        mock_review = self._make_mock_review(review_id=review_id, status="RESOLVED")

        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(return_value=mock_review)

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)

            with pytest.raises(ValidationError) as exc_info:
                await service.update_status(review_id, "CLOSED")

            assert "Resolution notes are required" in str(exc_info.value)
            assert exc_info.value.details["status"] == "CLOSED"

    @pytest.mark.asyncio
    async def test_update_status_review_not_found(self, mock_session):
        """Test updating status for non-existent review raises NotFoundError."""
        review_id = uuid4()

        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(return_value=None)

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)

            with pytest.raises(NotFoundError) as exc_info:
                await service.update_status(review_id, "IN_REVIEW")

            assert "Review not found" in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_assign_analyst_success(self, mock_session):
        """Test assigning an analyst to a review successfully."""
        review_id = uuid4()
        analyst_id = "analyst_123"
        mock_review = self._make_mock_review(review_id=review_id)
        updated_review = self._make_mock_review(
            review_id=review_id, assigned_analyst_id=analyst_id, status="IN_REVIEW"
        )

        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(return_value=mock_review)
        mock_repo.assign = AsyncMock(return_value=updated_review)

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)
            result = await service.assign_analyst(review_id, analyst_id)

            assert result["assigned_analyst_id"] == analyst_id
            mock_repo.assign.assert_called_once_with(review_id=review_id, analyst_id=analyst_id)

    @pytest.mark.asyncio
    async def test_assign_analyst_review_not_found(self, mock_session):
        """Test assigning analyst to non-existent review raises NotFoundError."""
        review_id = uuid4()
        analyst_id = "analyst_123"

        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(return_value=None)

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)

            with pytest.raises(NotFoundError) as exc_info:
                await service.assign_analyst(review_id, analyst_id)

            assert "Review not found" in str(exc_info.value)
            assert exc_info.value.details["review_id"] == str(review_id)

    @pytest.mark.asyncio
    async def test_resolve_success(self, mock_session):
        """Test resolving a review successfully."""
        review_id = uuid4()
        resolution_code = "LEGITIMATE"
        resolution_notes = "Customer verified"
        resolved_by = "analyst_123"

        mock_review = self._make_mock_review(review_id=review_id, status="IN_REVIEW")
        resolved_review = self._make_mock_review(
            review_id=review_id,
            status="RESOLVED",
            resolution_code=resolution_code,
            resolution_notes=resolution_notes,
            resolved_by=resolved_by,
        )

        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(return_value=mock_review)
        mock_repo.resolve = AsyncMock(return_value=resolved_review)

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)
            result = await service.resolve(
                review_id, resolution_code, resolution_notes, resolved_by
            )

            assert result["status"] == "RESOLVED"
            assert result["resolution_code"] == resolution_code
            assert result["resolution_notes"] == resolution_notes
            mock_repo.resolve.assert_called_once_with(
                review_id=review_id,
                resolution_code=resolution_code,
                resolution_notes=resolution_notes,
                resolved_by=resolved_by,
            )

    @pytest.mark.asyncio
    async def test_resolve_review_not_found(self, mock_session):
        """Test resolving a non-existent review raises NotFoundError."""
        review_id = uuid4()

        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(return_value=None)

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)

            with pytest.raises(NotFoundError) as exc_info:
                await service.resolve(review_id, "LEGITIMATE", "notes", "analyst")

            assert "Review not found" in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_resolve_already_closed(self, mock_session):
        """Test that resolving a closed review raises ValidationError."""
        review_id = uuid4()
        mock_review = self._make_mock_review(review_id=review_id, status="CLOSED")

        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(return_value=mock_review)

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)

            with pytest.raises(ValidationError) as exc_info:
                await service.resolve(review_id, "LEGITIMATE", "notes", "analyst")

            assert "Cannot resolve a closed review" in str(exc_info.value)
            assert exc_info.value.details["current_status"] == "CLOSED"

    @pytest.mark.asyncio
    async def test_escalate_success(self, mock_session):
        """Test escalating a review successfully."""
        review_id = uuid4()
        escalate_to = "supervisor_123"
        reason = "Complex case requires senior review"

        mock_review = self._make_mock_review(review_id=review_id, status="IN_REVIEW")
        escalated_review = self._make_mock_review(
            review_id=review_id,
            status="ESCALATED",
            escalated_to=escalate_to,
            escalation_reason=reason,
        )

        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(return_value=mock_review)
        mock_repo.escalate = AsyncMock(return_value=escalated_review)

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)
            result = await service.escalate(review_id, escalate_to, reason)

            assert result["status"] == "ESCALATED"
            assert result["escalated_to"] == escalate_to
            assert result["escalation_reason"] == reason
            mock_repo.escalate.assert_called_once_with(
                review_id=review_id, escalate_to=escalate_to, reason=reason
            )

    @pytest.mark.asyncio
    async def test_escalate_review_not_found(self, mock_session):
        """Test escalating a non-existent review raises NotFoundError."""
        review_id = uuid4()

        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(return_value=None)

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)

            with pytest.raises(NotFoundError) as exc_info:
                await service.escalate(review_id, "supervisor", "reason")

            assert "Review not found" in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_escalate_already_resolved(self, mock_session):
        """Test that escalating a resolved review raises ValidationError."""
        review_id = uuid4()
        mock_review = self._make_mock_review(review_id=review_id, status="RESOLVED")

        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(return_value=mock_review)

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)

            with pytest.raises(ValidationError) as exc_info:
                await service.escalate(review_id, "supervisor", "reason")

            assert "Cannot escalate a resolved review" in str(exc_info.value)
            assert exc_info.value.details["current_status"] == "RESOLVED"

    @pytest.mark.asyncio
    async def test_escalate_already_closed(self, mock_session):
        """Test that escalating a closed review raises ValidationError."""
        review_id = uuid4()
        mock_review = self._make_mock_review(review_id=review_id, status="CLOSED")

        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(return_value=mock_review)

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)

            with pytest.raises(ValidationError) as exc_info:
                await service.escalate(review_id, "supervisor", "reason")

            assert "Cannot escalate a closed review" in str(exc_info.value)
            assert exc_info.value.details["current_status"] == "CLOSED"

    @pytest.mark.asyncio
    async def test_validate_status_transition_valid(self, mock_session):
        """Test validate_status_transition returns True for valid transitions."""
        mock_repo = AsyncMock()

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)

            # Test various valid transitions
            assert service.validate_status_transition("PENDING", "IN_REVIEW") is True
            assert service.validate_status_transition("PENDING", "ESCALATED") is True
            assert service.validate_status_transition("PENDING", "RESOLVED") is True
            assert service.validate_status_transition("IN_REVIEW", "ESCALATED") is True
            assert service.validate_status_transition("ESCALATED", "RESOLVED") is True
            assert service.validate_status_transition("RESOLVED", "CLOSED") is True

    @pytest.mark.asyncio
    async def test_validate_status_transition_invalid(self, mock_session):
        """Test validate_status_transition returns False for invalid transitions."""
        mock_repo = AsyncMock()

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)

            # Test various invalid transitions
            assert service.validate_status_transition("CLOSED", "PENDING") is False
            assert service.validate_status_transition("RESOLVED", "PENDING") is False
            assert service.validate_status_transition("RESOLVED", "IN_REVIEW") is False
            assert service.validate_status_transition("INVALID", "PENDING") is False

    @pytest.mark.asyncio
    async def test_list_by_analyst_success(self, mock_session):
        """Test listing reviews by analyst successfully."""
        analyst_id = "analyst_123"
        mock_reviews = [
            self._make_mock_review(status="IN_REVIEW", assigned_analyst_id=analyst_id),
            self._make_mock_review(status="PENDING", assigned_analyst_id=analyst_id),
        ]

        mock_repo = AsyncMock()
        mock_repo.list_by_analyst = AsyncMock(return_value=(mock_reviews, "next_cursor", 10))

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)
            reviews, cursor, total = await service.list_by_analyst(analyst_id)

            assert len(reviews) == 2
            assert cursor == "next_cursor"
            assert total == 10
            mock_repo.list_by_analyst.assert_called_once_with(
                analyst_id=analyst_id, status=None, limit=50, cursor=None
            )

    @pytest.mark.asyncio
    async def test_list_by_analyst_with_filters(self, mock_session):
        """Test listing reviews by analyst with status filter and pagination."""
        analyst_id = "analyst_123"
        mock_reviews = [self._make_mock_review(status="RESOLVED", assigned_analyst_id=analyst_id)]

        mock_repo = AsyncMock()
        mock_repo.list_by_analyst = AsyncMock(return_value=(mock_reviews, None, 1))

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)
            reviews, cursor, total = await service.list_by_analyst(
                analyst_id, status="RESOLVED", limit=10, cursor="some_cursor"
            )

            assert len(reviews) == 1
            assert cursor is None
            assert total == 1
            mock_repo.list_by_analyst.assert_called_once_with(
                analyst_id=analyst_id, status="RESOLVED", limit=10, cursor="some_cursor"
            )

    @pytest.mark.asyncio
    async def test_list_unassigned_success(self, mock_session):
        """Test listing unassigned reviews successfully."""
        mock_reviews = [
            self._make_mock_review(status="PENDING", assigned_analyst_id=None),
            self._make_mock_review(status="ESCALATED", assigned_analyst_id=None),
        ]

        mock_repo = AsyncMock()
        mock_repo.list_unassigned = AsyncMock(return_value=(mock_reviews, "next_cursor", 20))

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)
            reviews, cursor, total = await service.list_unassigned()

            assert len(reviews) == 2
            assert cursor == "next_cursor"
            assert total == 20
            mock_repo.list_unassigned.assert_called_once_with(
                status=None, priority_filter=None, risk_level_filter=None, limit=50, cursor=None
            )

    @pytest.mark.asyncio
    async def test_list_unassigned_with_filters(self, mock_session):
        """Test listing unassigned reviews with filters."""
        mock_reviews = [
            self._make_mock_review(
                status="PENDING",
                assigned_analyst_id=None,
                priority=1,
                risk_level="HIGH",
            )
        ]

        mock_repo = AsyncMock()
        mock_repo.list_unassigned = AsyncMock(return_value=(mock_reviews, None, 1))

        with patch.object(
            ReviewService, "__init__", lambda self, session: setattr(self, "repo", mock_repo)
        ):
            service = ReviewService(mock_session)
            reviews, _, total = await service.list_unassigned(
                status=["PENDING", "IN_REVIEW"],
                priority_filter=2,
                risk_level_filter="HIGH",
                limit=25,
            )

            assert len(reviews) == 1
            assert total == 1
            mock_repo.list_unassigned.assert_called_once_with(
                status=["PENDING", "IN_REVIEW"],
                priority_filter=2,
                risk_level_filter="HIGH",
                limit=25,
                cursor=None,
            )


class TestCaseService:
    """Comprehensive tests for CaseService to increase coverage from 15% to 60%+."""

    @pytest.mark.asyncio
    async def test_create_case_success(self, mock_session):
        """Test successful case creation with all parameters."""
        mock_repo = AsyncMock()
        mock_repo.generate_case_number = AsyncMock(return_value="CASE-001")
        mock_repo.create = AsyncMock(
            return_value={
                "id": uuid4(),
                "case_number": "CASE-001",
                "case_type": "FRAUD_INVESTIGATION",
                "case_status": "OPEN",
                "title": "Test Case",
                "description": "Test description",
                "assigned_analyst_id": "analyst_123",
                "risk_level": "HIGH",
            }
        )
        mock_repo.log_activity = AsyncMock()

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            result = await service.create_case(
                case_type="FRAUD_INVESTIGATION",
                title="Test Case",
                description="Test description",
                transaction_ids=[uuid4(), uuid4()],
                assigned_analyst_id="analyst_123",
                risk_level="HIGH",
                analyst_id="analyst_123",
                analyst_name="Test Analyst",
            )

            assert result["case_number"] == "CASE-001"
            assert result["title"] == "Test Case"
            assert result["case_status"] == "OPEN"
            mock_repo.create.assert_called_once()
            mock_repo.log_activity.assert_called_once()

    @pytest.mark.asyncio
    async def test_create_case_with_empty_title(self, mock_session):
        """Test create_case with empty title raises ValidationError."""
        mock_repo = AsyncMock()

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            with pytest.raises(ValidationError) as exc_info:
                await service.create_case(
                    case_type="FRAUD_INVESTIGATION",
                    title="",
                )

            assert "Case title is required" in str(exc_info.value)
            assert exc_info.value.details["title"] == ""

    @pytest.mark.asyncio
    async def test_create_case_with_whitespace_only_title(self, mock_session):
        """Test create_case with whitespace-only title raises ValidationError."""
        mock_repo = AsyncMock()

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            with pytest.raises(ValidationError) as exc_info:
                await service.create_case(
                    case_type="FRAUD_INVESTIGATION",
                    title="   ",
                )

            assert "Case title is required" in str(exc_info.value)
            assert exc_info.value.details["title"] == "   "

    @pytest.mark.asyncio
    async def test_create_case_with_none_title(self, mock_session):
        """Test create_case with None title raises ValidationError."""
        mock_repo = AsyncMock()

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            with pytest.raises(ValidationError) as exc_info:
                await service.create_case(
                    case_type="FRAUD_INVESTIGATION",
                    title=None,
                )

            assert "Case title is required" in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_create_case_minimal_parameters(self, mock_session):
        """Test create_case with only required parameters."""
        case_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.generate_case_number = AsyncMock(return_value="CASE-002")
        mock_repo.create = AsyncMock(
            return_value={
                "id": case_id,
                "case_number": "CASE-002",
                "case_type": "FRAUD_INVESTIGATION",
                "case_status": "OPEN",
                "title": "Minimal Case",
            }
        )
        mock_repo.log_activity = AsyncMock()

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            result = await service.create_case(
                case_type="FRAUD_INVESTIGATION",
                title="Minimal Case",
            )

            assert result["case_number"] == "CASE-002"
            assert result["title"] == "Minimal Case"

    @pytest.mark.asyncio
    async def test_get_case_by_id_success(self, mock_session):
        """Test successful case retrieval by ID."""
        case_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(
            return_value={
                "id": case_id,
                "case_number": "CASE-001",
                "case_status": "OPEN",
            }
        )

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            result = await service.get_case(case_id)

            assert result["id"] == case_id
            mock_repo.get_by_id.assert_called_once_with(case_id)

    @pytest.mark.asyncio
    async def test_get_case_by_id_not_found(self, mock_session):
        """Test get_case with non-existent ID raises NotFoundError."""
        case_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(return_value=None)

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            with pytest.raises(NotFoundError) as exc_info:
                await service.get_case(case_id)

            assert "Case not found" in str(exc_info.value)
            assert exc_info.value.details["case_id"] == str(case_id)

    @pytest.mark.asyncio
    async def test_get_case_by_number_success(self, mock_session):
        """Test successful case retrieval by case number."""
        mock_repo = AsyncMock()
        mock_repo.get_by_case_number = AsyncMock(
            return_value={
                "id": uuid4(),
                "case_number": "CASE-001",
                "case_status": "OPEN",
            }
        )

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            result = await service.get_case_by_number("CASE-001")

            assert result["case_number"] == "CASE-001"
            mock_repo.get_by_case_number.assert_called_once_with("CASE-001")

    @pytest.mark.asyncio
    async def test_get_case_by_number_not_found(self, mock_session):
        """Test get_case_by_number with non-existent case number raises NotFoundError."""
        mock_repo = AsyncMock()
        mock_repo.get_by_case_number = AsyncMock(return_value=None)

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            with pytest.raises(NotFoundError) as exc_info:
                await service.get_case_by_number("CASE-NONEXISTENT")

            assert "Case not found" in str(exc_info.value)
            assert exc_info.value.details["case_number"] == "CASE-NONEXISTENT"

    @pytest.mark.asyncio
    async def test_update_case_all_parameters(self, mock_session):
        """Test update_case with all parameters."""
        case_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(
            return_value={
                "id": case_id,
                "case_number": "CASE-001",
                "case_status": "OPEN",
                "assigned_analyst_id": "old_analyst",
            }
        )
        mock_repo.update = AsyncMock(
            return_value={
                "id": case_id,
                "case_status": "IN_PROGRESS",
                "case_type": "ACCOUNT_TAKEOVER",
                "title": "Updated Title",
                "description": "Updated description",
                "assigned_analyst_id": "new_analyst",
                "risk_level": "CRITICAL",
            }
        )
        mock_repo.log_activity = AsyncMock()

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            result = await service.update_case(
                case_id=case_id,
                case_status="IN_PROGRESS",
                case_type="ACCOUNT_TAKEOVER",
                title="Updated Title",
                description="Updated description",
                assigned_analyst_id="new_analyst",
                risk_level="CRITICAL",
                resolution_summary="Issue resolved",
                analyst_id="analyst_123",
                analyst_name="Test Analyst",
            )

            assert result["case_status"] == "IN_PROGRESS"
            assert result["assigned_analyst_id"] == "new_analyst"
            mock_repo.update.assert_called_once()
            mock_repo.log_activity.assert_called_once()

    @pytest.mark.asyncio
    async def test_update_case_case_not_found(self, mock_session):
        """Test update_case with non-existent case raises NotFoundError."""
        case_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(return_value=None)

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            with pytest.raises(NotFoundError) as exc_info:
                await service.update_case(case_id, title="Updated")

            assert "Case not found" in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_update_case_no_changes(self, mock_session):
        """Test update_case with no actual changes (all None)."""
        case_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(
            return_value={
                "id": case_id,
                "case_number": "CASE-001",
                "case_status": "OPEN",
                "assigned_analyst_id": "analyst_123",
            }
        )
        mock_repo.update = AsyncMock(
            return_value={
                "id": case_id,
                "case_status": "OPEN",
            }
        )

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            result = await service.update_case(case_id)

            assert result["case_status"] == "OPEN"
            mock_repo.log_activity.assert_not_called()

    @pytest.mark.asyncio
    async def test_update_case_only_status(self, mock_session):
        """Test update_case with only case_status changed."""
        case_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(
            return_value={
                "id": case_id,
                "case_number": "CASE-001",
                "case_status": "OPEN",
            }
        )
        mock_repo.update = AsyncMock(
            return_value={
                "id": case_id,
                "case_status": "IN_PROGRESS",
            }
        )
        mock_repo.log_activity = AsyncMock()

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            result = await service.update_case(case_id, case_status="IN_PROGRESS")

            assert result["case_status"] == "IN_PROGRESS"
            mock_repo.log_activity.assert_called_once()
            call_args = mock_repo.log_activity.call_args
            assert call_args.kwargs["old_values"]["case_status"] == "OPEN"
            assert call_args.kwargs["new_values"]["case_status"] == "IN_PROGRESS"

    @pytest.mark.asyncio
    async def test_update_case_only_assigned_analyst(self, mock_session):
        """Test update_case with only assigned_analyst_id changed."""
        case_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(
            return_value={
                "id": case_id,
                "case_number": "CASE-001",
                "case_status": "OPEN",
                "assigned_analyst_id": "old_analyst",
            }
        )
        mock_repo.update = AsyncMock(
            return_value={
                "id": case_id,
                "assigned_analyst_id": "new_analyst",
            }
        )
        mock_repo.log_activity = AsyncMock()

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            result = await service.update_case(case_id, assigned_analyst_id="new_analyst")

            assert result["assigned_analyst_id"] == "new_analyst"
            mock_repo.log_activity.assert_called_once()

    @pytest.mark.asyncio
    async def test_update_case_same_status_no_activity_log(self, mock_session):
        """Test update_case when status is same as current (no activity logged)."""
        case_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(
            return_value={
                "id": case_id,
                "case_number": "CASE-001",
                "case_status": "OPEN",
            }
        )
        mock_repo.update = AsyncMock(
            return_value={
                "id": case_id,
                "case_status": "OPEN",
            }
        )

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            await service.update_case(case_id, case_status="OPEN")

            mock_repo.log_activity.assert_not_called()

    @pytest.mark.asyncio
    async def test_add_transaction_to_case_success(self, mock_session):
        """Test successfully adding transaction to case."""
        case_id = uuid4()
        transaction_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(
            return_value={
                "id": case_id,
                "case_number": "CASE-001",
                "case_status": "OPEN",
            }
        )
        mock_repo.add_transaction = AsyncMock(return_value=True)
        mock_repo.log_activity = AsyncMock()

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            await service.add_transaction_to_case(
                case_id=case_id,
                transaction_id=transaction_id,
                analyst_id="analyst_123",
                analyst_name="Test Analyst",
            )

            mock_repo.add_transaction.assert_called_once_with(
                case_id=case_id, transaction_id=transaction_id
            )
            mock_repo.log_activity.assert_called_once()
            assert mock_repo.log_activity.call_args.kwargs["activity_type"] == "TRANSACTION_ADDED"

    @pytest.mark.asyncio
    async def test_add_transaction_to_case_not_found(self, mock_session):
        """Test add_transaction_to_case with non-existent case raises NotFoundError."""
        case_id = uuid4()
        transaction_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(return_value=None)

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            with pytest.raises(NotFoundError) as exc_info:
                await service.add_transaction_to_case(case_id, transaction_id)

            assert "Case not found" in str(exc_info.value)
            assert exc_info.value.details["case_id"] == str(case_id)

    @pytest.mark.asyncio
    async def test_add_transaction_to_case_resolved_case(self, mock_session):
        """Test add_transaction_to_case on resolved case raises ValidationError."""
        case_id = uuid4()
        transaction_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(
            return_value={
                "id": case_id,
                "case_number": "CASE-001",
                "case_status": "RESOLVED",
            }
        )

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            with pytest.raises(ValidationError) as exc_info:
                await service.add_transaction_to_case(case_id, transaction_id)

            assert "Cannot add transactions to a resolved case" in str(exc_info.value)
            assert exc_info.value.details["case_status"] == "RESOLVED"

    @pytest.mark.asyncio
    async def test_add_transaction_to_case_closed_case(self, mock_session):
        """Test add_transaction_to_case on closed case raises ValidationError."""
        case_id = uuid4()
        transaction_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(
            return_value={
                "id": case_id,
                "case_number": "CASE-001",
                "case_status": "CLOSED",
            }
        )

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            with pytest.raises(ValidationError) as exc_info:
                await service.add_transaction_to_case(case_id, transaction_id)

            assert "Cannot add transactions to a closed case" in str(exc_info.value)
            assert exc_info.value.details["case_status"] == "CLOSED"

    @pytest.mark.asyncio
    async def test_add_transaction_to_case_transaction_not_found(self, mock_session):
        """Test add_transaction_to_case when transaction doesn't exist (repo returns False)."""
        case_id = uuid4()
        transaction_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(
            return_value={
                "id": case_id,
                "case_number": "CASE-001",
                "case_status": "OPEN",
            }
        )
        mock_repo.add_transaction = AsyncMock(return_value=False)

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            await service.add_transaction_to_case(case_id, transaction_id)

            mock_repo.add_transaction.assert_called_once()
            mock_repo.log_activity.assert_not_called()

    @pytest.mark.asyncio
    async def test_remove_transaction_from_case_success(self, mock_session):
        """Test successfully removing transaction from case."""
        case_id = uuid4()
        transaction_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(
            return_value={
                "id": case_id,
                "case_number": "CASE-001",
                "case_status": "OPEN",
            }
        )
        mock_repo.remove_transaction = AsyncMock(return_value=True)
        mock_repo.log_activity = AsyncMock()

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            await service.remove_transaction_from_case(
                case_id=case_id,
                transaction_id=transaction_id,
                analyst_id="analyst_123",
                analyst_name="Test Analyst",
            )

            mock_repo.remove_transaction.assert_called_once_with(
                case_id=case_id, transaction_id=transaction_id
            )
            mock_repo.log_activity.assert_called_once()
            assert mock_repo.log_activity.call_args.kwargs["activity_type"] == "TRANSACTION_REMOVED"

    @pytest.mark.asyncio
    async def test_remove_transaction_from_case_not_found(self, mock_session):
        """Test remove_transaction_from_case with non-existent case raises NotFoundError."""
        case_id = uuid4()
        transaction_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(return_value=None)

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            with pytest.raises(NotFoundError) as exc_info:
                await service.remove_transaction_from_case(case_id, transaction_id)

            assert "Case not found" in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_remove_transaction_from_case_resolved_case(self, mock_session):
        """Test remove_transaction_from_case on resolved case raises ValidationError."""
        case_id = uuid4()
        transaction_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(
            return_value={
                "id": case_id,
                "case_number": "CASE-001",
                "case_status": "RESOLVED",
            }
        )

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            with pytest.raises(ValidationError) as exc_info:
                await service.remove_transaction_from_case(case_id, transaction_id)

            assert "Cannot remove transactions from a resolved case" in str(exc_info.value)
            assert exc_info.value.details["case_status"] == "RESOLVED"

    @pytest.mark.asyncio
    async def test_remove_transaction_from_case_closed_case(self, mock_session):
        """Test remove_transaction_from_case on closed case raises ValidationError."""
        case_id = uuid4()
        transaction_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(
            return_value={
                "id": case_id,
                "case_number": "CASE-001",
                "case_status": "CLOSED",
            }
        )

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            with pytest.raises(ValidationError) as exc_info:
                await service.remove_transaction_from_case(case_id, transaction_id)

            assert "Cannot remove transactions from a closed case" in str(exc_info.value)
            assert exc_info.value.details["case_status"] == "CLOSED"

    @pytest.mark.asyncio
    async def test_remove_transaction_from_case_transaction_not_in_case(self, mock_session):
        """Test remove_transaction_from_case when transaction not in case."""
        case_id = uuid4()
        transaction_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(
            return_value={
                "id": case_id,
                "case_number": "CASE-001",
                "case_status": "OPEN",
            }
        )
        mock_repo.remove_transaction = AsyncMock(return_value=False)

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            await service.remove_transaction_from_case(case_id, transaction_id)

            mock_repo.remove_transaction.assert_called_once()
            mock_repo.log_activity.assert_not_called()

    @pytest.mark.asyncio
    async def test_resolve_case_success(self, mock_session):
        """Test successfully resolving a case."""
        case_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(
            return_value={
                "id": case_id,
                "case_number": "CASE-001",
                "case_status": "OPEN",
            }
        )
        mock_repo.update = AsyncMock(
            return_value={
                "id": case_id,
                "case_status": "RESOLVED",
                "resolution_summary": "Fraud confirmed",
            }
        )
        mock_repo.log_activity = AsyncMock()

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            result = await service.resolve_case(
                case_id=case_id,
                resolution_summary="Fraud confirmed",
                resolved_by="analyst_123",
                analyst_name="Test Analyst",
            )

            assert result["case_status"] == "RESOLVED"
            mock_repo.update.assert_called_once()
            mock_repo.log_activity.assert_called_once()
            assert mock_repo.log_activity.call_args.kwargs["activity_type"] == "CASE_RESOLVED"

    @pytest.mark.asyncio
    async def test_resolve_case_not_found(self, mock_session):
        """Test resolve_case with non-existent case raises NotFoundError."""
        case_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(return_value=None)

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            with pytest.raises(NotFoundError) as exc_info:
                await service.resolve_case(case_id, "Resolution", "analyst_123")

            assert "Case not found" in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_resolve_case_already_closed(self, mock_session):
        """Test resolve_case on already closed case raises ValidationError."""
        case_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(
            return_value={
                "id": case_id,
                "case_number": "CASE-001",
                "case_status": "CLOSED",
            }
        )

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            with pytest.raises(ValidationError) as exc_info:
                await service.resolve_case(case_id, "Resolution", "analyst_123")

            assert "Case is already closed" in str(exc_info.value)
            assert exc_info.value.details["case_status"] == "CLOSED"

    @pytest.mark.asyncio
    async def test_resolve_case_empty_resolution_summary(self, mock_session):
        """Test resolve_case with empty resolution_summary raises ValidationError."""
        case_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(
            return_value={
                "id": case_id,
                "case_number": "CASE-001",
                "case_status": "OPEN",
            }
        )

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            with pytest.raises(ValidationError) as exc_info:
                await service.resolve_case(case_id, "", "analyst_123")

            assert "Resolution summary is required" in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_resolve_case_whitespace_only_resolution_summary(self, mock_session):
        """Test resolve_case with whitespace-only resolution_summary raises ValidationError."""
        case_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(
            return_value={
                "id": case_id,
                "case_number": "CASE-001",
                "case_status": "OPEN",
            }
        )

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            with pytest.raises(ValidationError) as exc_info:
                await service.resolve_case(case_id, "   ", "analyst_123")

            assert "Resolution summary is required" in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_list_cases_with_filters(self, mock_session):
        """Test list_cases with various filters."""
        mock_repo = AsyncMock()
        mock_repo.list = AsyncMock(
            return_value=(
                [{"id": uuid4(), "case_number": "CASE-001"}],
                "next_cursor",
                10,
            )
        )

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            cases, next_cursor, total = await service.list_cases(
                case_status="OPEN",
                case_type="FRAUD_INVESTIGATION",
                assigned_analyst_id="analyst_123",
                risk_level="HIGH",
                limit=25,
                cursor="some_cursor",
            )

            assert len(cases) == 1
            assert next_cursor == "next_cursor"
            assert total == 10
            mock_repo.list.assert_called_once_with(
                case_status="OPEN",
                case_type="FRAUD_INVESTIGATION",
                assigned_analyst_id="analyst_123",
                risk_level="HIGH",
                limit=25,
                cursor="some_cursor",
            )

    @pytest.mark.asyncio
    async def test_list_cases_no_filters(self, mock_session):
        """Test list_cases with no filters."""
        mock_repo = AsyncMock()
        mock_repo.list = AsyncMock(return_value=([], None, 0))

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            cases, next_cursor, total = await service.list_cases()

            assert cases == []
            assert next_cursor is None
            assert total == 0

    @pytest.mark.asyncio
    async def test_get_case_transactions_success(self, mock_session):
        """Test getting transactions for a case."""
        case_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(
            return_value={
                "id": case_id,
                "case_number": "CASE-001",
                "case_status": "OPEN",
            }
        )
        mock_repo.get_transactions = AsyncMock(
            return_value=[
                {"transaction_id": uuid4(), "amount": 100.00},
                {"transaction_id": uuid4(), "amount": 200.00},
            ]
        )

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            transactions = await service.get_case_transactions(case_id)

            assert len(transactions) == 2
            mock_repo.get_transactions.assert_called_once_with(case_id=case_id, limit=100)

    @pytest.mark.asyncio
    async def test_get_case_transactions_not_found(self, mock_session):
        """Test get_case_transactions with non-existent case raises NotFoundError."""
        case_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(return_value=None)

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            with pytest.raises(NotFoundError) as exc_info:
                await service.get_case_transactions(case_id)

            assert "Case not found" in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_get_case_transactions_with_limit(self, mock_session):
        """Test getting transactions for a case with custom limit."""
        case_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(
            return_value={
                "id": case_id,
                "case_number": "CASE-001",
            }
        )
        mock_repo.get_transactions = AsyncMock(return_value=[])

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            await service.get_case_transactions(case_id, limit=50)

            mock_repo.get_transactions.assert_called_once_with(case_id=case_id, limit=50)

    @pytest.mark.asyncio
    async def test_get_case_activity_success(self, mock_session):
        """Test getting activity log for a case."""
        case_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(
            return_value={
                "id": case_id,
                "case_number": "CASE-001",
            }
        )
        mock_repo.get_activity = AsyncMock(
            return_value=[
                {
                    "id": uuid4(),
                    "activity_type": "CASE_CREATED",
                    "activity_description": "Case created",
                }
            ]
        )

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            activities = await service.get_case_activity(case_id)

            assert len(activities) == 1
            assert activities[0]["activity_type"] == "CASE_CREATED"
            mock_repo.get_activity.assert_called_once_with(case_id=case_id, limit=100)

    @pytest.mark.asyncio
    async def test_get_case_activity_not_found(self, mock_session):
        """Test get_case_activity with non-existent case raises NotFoundError."""
        case_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(return_value=None)

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            with pytest.raises(NotFoundError) as exc_info:
                await service.get_case_activity(case_id)

            assert "Case not found" in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_update_case_aggregates(self, mock_session):
        """Test update_case_aggregates delegates to get_case."""
        case_id = uuid4()
        mock_repo = AsyncMock()
        mock_repo.get_by_id = AsyncMock(
            return_value={
                "id": case_id,
                "case_number": "CASE-001",
                "total_transaction_count": 5,
                "total_transaction_amount": 500.00,
            }
        )

        with patch.object(
            CaseService,
            "__init__",
            lambda self, session: setattr(self, "repo", mock_repo),
        ):
            service = CaseService(mock_session)
            service.repo = mock_repo

            result = await service.update_case_aggregates(case_id)

            assert result["id"] == case_id
            mock_repo.get_by_id.assert_called_once_with(case_id)

"""SQL query inspection and validation helpers for unit tests.

These utilities allow capturing and inspecting actual SQL queries
generated by repositories, enabling validation of JOIN conditions,
WHERE clauses, and other SQL constructs without needing a real database.

Example:
    capture = SQLCapture()
    mock_session.execute = AsyncMock(side_effect=capture.execute)

    await repo.list_unassigned(risk_level_filter="HIGH")

    capture.assert_join_exists("transaction_reviews r", "transactions t", "r.transaction_id = t.id")
    capture.assert_where_exists("r.status = 'PENDING'")
"""

import re
from dataclasses import dataclass, field
from typing import Any
from unittest.mock import MagicMock


@dataclass
class ExecutedQuery:
    """Represents a single executed SQL query with its parameters."""

    sql: str
    params: dict[str, Any]

    def __str__(self) -> str:
        """Return a formatted string representation of the query."""
        return f"SQL: {self.sql}\nParams: {self.params}"

    def contains(self, pattern: str) -> bool:
        """Check if the SQL contains the given pattern (case-insensitive)."""
        return pattern.lower() in self.sql.lower()

    def has_join(self, table1: str, table2: str, on_condition: str) -> bool:
        """Check if the query has a JOIN with the specific condition."""
        # Normalize SQL for comparison
        normalized = re.sub(r"\s+", " ", self.sql.lower())

        # Build pattern to match
        join_pattern = f"{table1.lower()}.*?{table2.lower()}.*?{on_condition.lower()}"
        return re.search(join_pattern, normalized, re.DOTALL) is not None


@dataclass
class SQLCapture:
    """Helper to capture and inspect SQL queries for testing.

    This class is used to intercept SQLAlchemy session.execute() calls
    and capture the SQL queries for validation in tests.

    Example:
        capture = SQLCapture()
        mock_session = MagicMock()
        mock_session.execute = AsyncMock(side_effect=capture.execute)

        # Call repository method
        await repo.list_unassigned(risk_level_filter="HIGH")

        # Validate the SQL
        capture.assert_join_exists(
            "transaction_reviews r", "transactions t", "r.transaction_id = t.id"
        )
    """

    queries: list[ExecutedQuery] = field(default_factory=list)

    async def execute(self, query, params: dict[str, Any] | None = None) -> MagicMock:
        """Capture SQL query execution for inspection.

        Args:
            query: The SQL query (could be a text() clause or raw SQL)
            params: Query parameters

        Returns:
            A mock result object that can be used like a real DB result
        """
        sql_str = str(query)
        self.queries.append(ExecutedQuery(sql=sql_str, params=params or {}))

        # Return a mock result that behaves like a real DB result
        return self._create_mock_result()

    def _create_mock_result(self) -> MagicMock:
        """Create a mock result object that behaves like a SQLAlchemy result."""
        mock_result = MagicMock()

        # For scalar() calls
        mock_result.scalar.return_value = 0

        # For fetchone() calls
        mock_result.fetchone.return_value = None

        # For fetchall() calls
        mock_result.fetchall.return_value = []

        # For rowcount
        mock_result.rowcount = 0

        return mock_result

    def assert_query_count(self, expected_count: int) -> None:
        """Assert that exactly N queries were executed."""
        actual_count = len(self.queries)
        assert actual_count == expected_count, (
            f"Expected {expected_count} queries, but {actual_count} were executed. "
            f"Queries:\n" + "\n".join(f"  - {q}" for q in self.queries)
        )

    def assert_join_exists(self, table_or_pattern: str, on_condition: str | None = None) -> None:
        """Assert that a JOIN with the specified pattern exists in the queries.

        Args:
            table_or_pattern: Table name or pattern (e.g., "transaction_reviews r")
            on_condition: Optional ON condition to verify (e.g., "r.transaction_id = t.id")

        Raises:
            AssertionError: If no query contains the expected JOIN
        """
        found = False
        for i, query in enumerate(self.queries):
            if query.contains(table_or_pattern):
                if on_condition is None or query.contains(on_condition):
                    found = True
                    break
                else:
                    # Found the table join but wrong condition
                    raise AssertionError(
                        f"Found JOIN with '{table_or_pattern}' but ON condition "
                        f"'{on_condition}' not found in query {i + 1}:\n{query.sql}"
                    )

        if not found:
            condition_msg = f" with ON condition '{on_condition}'" if on_condition else ""
            raise AssertionError(
                f"Expected JOIN{condition_msg} not found in any query.\n"
                f"Queries executed:\n"
                + "\n".join(f"  {i + 1}. {q.sql}" for i, q in enumerate(self.queries))
            )

    def assert_join_not_uses(self, table1: str, table2: str, wrong_on_condition: str) -> None:
        """Assert that a JOIN does NOT use the specified (wrong) ON condition.

        This is useful for catching bugs like `r.transaction_id = t.transaction_id`
        when it should be `r.transaction_id = t.id`.

        Args:
            table1: First table name
            table2: Second table name
            wrong_on_condition: The WRONG ON condition that should NOT be present

        Raises:
            AssertionError: If the wrong JOIN condition is found
        """
        for i, query in enumerate(self.queries):
            if query.has_join(table1, table2, wrong_on_condition):
                raise AssertionError(
                    f"Found WRONG JOIN condition in query {i + 1}: '{wrong_on_condition}'\n"
                    f"This should reference the primary key (id), not the business key "
                    f"(transaction_id).\n"
                    f"Query:\n{query.sql}"
                )

    def assert_where_exists(self, condition: str) -> None:
        """Assert that a WHERE condition exists in the queries.

        Args:
            condition: The WHERE condition to look for

        Raises:
            AssertionError: If the WHERE condition is not found
        """
        for _i, query in enumerate(self.queries):
            if query.contains(condition):
                return

        raise AssertionError(
            f"WHERE condition '{condition}' not found in any query.\n"
            f"Queries executed:\n"
            + "\n".join(f"  {_i + 1}. {q.sql}" for _i, q in enumerate(self.queries))
        )

    def assert_where_not_exists(self, condition: str) -> None:
        """Assert that a WHERE condition does NOT exist in the queries.

        Args:
            condition: The WHERE condition that should NOT be present

        Raises:
            AssertionError: If the WHERE condition is found
        """
        for i, query in enumerate(self.queries):
            if query.contains(condition):
                raise AssertionError(
                    f"Unexpected WHERE condition '{condition}' found in query {i + 1}:\n{query.sql}"
                )

    def get_query(self, index: int = 0) -> ExecutedQuery:
        """Get a specific query by index.

        Args:
            index: Zero-based index of the query to retrieve

        Returns:
            The ExecutedQuery at the specified index

        Raises:
            IndexError: If the index is out of range
        """
        if index >= len(self.queries):
            raise IndexError(
                f"Query index {index} out of range. Only {len(self.queries)} queries executed."
            )
        return self.queries[index]

    def get_all_sql(self) -> list[str]:
        """Get all executed SQL as a list of strings."""
        return [q.sql for q in self.queries]

    def clear(self) -> None:
        """Clear all captured queries."""
        self.queries.clear()


class SQLInspector:
    """Context manager for temporarily capturing SQL queries.

    Example:
        with SQLInspector(mock_session) as capture:
            await repo.list_unassigned(risk_level_filter="HIGH")

        # After context exits, inspect the captured queries
        capture.assert_join_exists("transaction_reviews r", "r.transaction_id = t.id")
    """

    def __init__(self, mock_session: MagicMock):
        """Initialize the SQL inspector.

        Args:
            mock_session: The mock SQLAlchemy session to intercept
        """
        self.mock_session = mock_session
        self.capture = SQLCapture()
        self.original_execute = None

    def __enter__(self) -> SQLInspector:
        """Enter the context and start capturing SQL."""
        # Import AsyncMock here to avoid issues with pytest
        from unittest.mock import AsyncMock

        self.original_execute = self.mock_session.execute
        self.mock_session.execute = AsyncMock(side_effect=self.capture.execute)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        """Exit the context and restore original execute method."""
        if self.original_execute:
            self.mock_session.execute = self.original_execute

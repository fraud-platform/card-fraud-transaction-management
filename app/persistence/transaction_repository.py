"""Transaction repository using psycopg v3 and SQLAlchemy 2.0 async.

Tables: fraud_gov.transactions, fraud_gov.transaction_rule_matches

Schema matches fraud_transactions_schema.sql DDL.

IMPORTANT: Understanding transaction IDs
----------------------------------------
The transactions table has TWO UUID columns with DIFFERENT purposes:

  1. id (PK)           = Surrogate primary key, uniquely identifies THIS DATABASE ROW
                         Generated by Transaction Management app (UUIDv7)
                         Used for foreign key references in child tables

  2. transaction_id    = Business transaction ID from Rule Engine / payment system
                         Passed through from Rule Engine (UUIDv7)
                         Used for idempotency and business lookups

FOREIGN KEY REFERENCE PATTERN:
  Child tables (transaction_reviews, transaction_rule_matches, etc.)
  have `transaction_id UUID NOT NULL REFERENCES fraud_gov.transactions(id)`

  This means child.transaction_id â†’ parent.id (the PK), NOT parent.transaction_id!

  CORRECT JOIN: FROM transaction_reviews r JOIN transactions t ON r.transaction_id = t.id

  # WRONG JOIN: Uses business key instead of PK (DO NOT USE)
  # FROM transaction_reviews r JOIN transactions t ON r.transaction_id = t.transaction_id
"""

import logging
from dataclasses import dataclass
from datetime import datetime
from typing import Any
from uuid import UUID

from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession

from app.persistence.base import BaseCursor

logger = logging.getLogger(__name__)

# Shared column list for transaction queries (reduces duplication)
_TRANSACTION_COLUMNS = """id, transaction_id, evaluation_type, card_id, card_last4, card_network,
       transaction_amount, transaction_currency, merchant_id, merchant_category_code,
       decision, decision_reason, decision_score,
       ruleset_key, ruleset_id, ruleset_version,
       risk_level,
       transaction_context, velocity_snapshot, velocity_results, engine_metadata,
       transaction_timestamp, ingestion_timestamp,
       kafka_topic, kafka_partition, kafka_offset, source_message_id,
       trace_id, request_id, session_id,
       raw_payload, ingestion_source,
       created_at, updated_at"""


@dataclass
class TransactionCursor(BaseCursor):
    """Cursor for keyset pagination using transaction_timestamp."""

    def __init__(
        self,
        *,
        timestamp: datetime | None = None,
        id: UUID | None = None,
        transaction_timestamp: datetime | None = None,
        transaction_id: UUID | None = None,
    ):
        """Initialize cursor with backward-compatible parameter names."""
        # Use old names if provided, otherwise use new names
        ts = transaction_timestamp or timestamp
        uid = transaction_id or id
        if ts is None or uid is None:
            raise TypeError(  # noqa: E501
                "TransactionCursor requires timestamp/id or transaction_timestamp/transaction_id"
            )
        super().__init__(timestamp=ts, id=uid)

    @property
    def transaction_timestamp(self) -> datetime:
        return self.timestamp

    @property
    def transaction_id(self) -> UUID:
        return self.id


class TransactionRepository:
    """Repository for fraud_gov.transactions data access."""

    def __init__(self, session: AsyncSession):
        self.session = session

    async def get_by_transaction_id(
        self, transaction_id: UUID, evaluation_type: str | None = None
    ) -> dict[str, Any] | None:
        """Get transaction by transaction_id (and optionally evaluation_type).

        If evaluation_type is provided, returns the specific event.
        Otherwise returns the most recent event for this transaction_id.
        """
        if evaluation_type:
            query = (
                f"SELECT {_TRANSACTION_COLUMNS} FROM fraud_gov.transactions "
                f"WHERE transaction_id = :transaction_id AND evaluation_type = :evaluation_type "
                f"ORDER BY transaction_timestamp DESC LIMIT 1"
            )
            result = await self.session.execute(
                text(query), {"transaction_id": transaction_id, "evaluation_type": evaluation_type}
            )
        else:
            query = (
                f"SELECT {_TRANSACTION_COLUMNS} FROM fraud_gov.transactions "
                f"WHERE transaction_id = :transaction_id "
                f"ORDER BY transaction_timestamp DESC LIMIT 1"
            )
            result = await self.session.execute(text(query), {"transaction_id": transaction_id})
        row = result.fetchone()
        if row is None:
            return None
        return self._row_to_dict(row)

    async def get_by_id(self, id: UUID) -> dict[str, Any] | None:
        """Get transaction by primary key id."""
        query = f"SELECT {_TRANSACTION_COLUMNS} FROM fraud_gov.transactions WHERE id = :id"
        result = await self.session.execute(text(query), {"id": id})
        row = result.fetchone()
        if row is None:
            return None
        return self._row_to_dict(row)

    async def list(
        self,
        card_id: str | None = None,
        decision: str | None = None,
        merchant_id: str | None = None,
        from_date: datetime | None = None,
        to_date: datetime | None = None,
        review_status: str | None = None,
        risk_level: str | None = None,
        case_id: UUID | None = None,
        rule_id: UUID | None = None,
        ruleset_id: UUID | None = None,
        assigned_to_me: bool = False,
        assigned_analyst_id: str | None = None,
        min_amount: float | None = None,
        max_amount: float | None = None,
        limit: int = 50,
        cursor: str | None = None,
    ) -> tuple[list[dict[str, Any]], str | None, int]:
        """List transactions with keyset pagination.

        Args:
            card_id: Filter by card ID
            decision: Filter by decision
            merchant_id: Filter by merchant ID
            from_date: Filter transactions from this date
            to_date: Filter transactions until this date
            review_status: Filter by review status (requires join with reviews)
            risk_level: Filter by risk level
            case_id: Filter by case ID (requires join with reviews)
            rule_id: Filter by rule ID (requires join with rule_matches)
            ruleset_id: Filter by ruleset ID
            assigned_to_me: Filter by assigned analyst
            assigned_analyst_id: Analyst ID for assigned_to_me filter
            min_amount: Minimum transaction amount
            max_amount: Maximum transaction amount
            limit: Maximum number of items to return
            cursor: Opaque cursor for pagination

        Returns:
            Tuple of (transactions list, next_cursor, total_count)
        """
        conditions = []
        params: dict[str, Any] = {}

        if card_id:
            conditions.append("t.card_id = :card_id")
            params["card_id"] = card_id

        if decision:
            conditions.append("t.decision = :decision")
            params["decision"] = decision

        if merchant_id:
            conditions.append("t.merchant_id = :merchant_id")
            params["merchant_id"] = merchant_id

        if from_date:
            conditions.append("t.transaction_timestamp >= :from_date")
            params["from_date"] = from_date

        if to_date:
            conditions.append("t.transaction_timestamp <= :to_date")
            params["to_date"] = to_date

        if risk_level:
            conditions.append("t.risk_level = :risk_level")
            params["risk_level"] = risk_level

        if ruleset_id:
            conditions.append("t.ruleset_id = :ruleset_id")
            params["ruleset_id"] = ruleset_id

        if min_amount is not None:
            conditions.append("t.transaction_amount >= :min_amount")
            params["min_amount"] = min_amount

        if max_amount is not None:
            conditions.append("t.transaction_amount <= :max_amount")
            params["max_amount"] = max_amount

        # Determine if we need to join with reviews
        needs_review_join = (
            review_status is not None
            or case_id is not None
            or assigned_to_me
            or assigned_analyst_id is not None
        )

        # Determine if we need to join with rule_matches
        needs_rule_join = rule_id is not None

        if review_status:
            conditions.append("r.status = :review_status")
            params["review_status"] = review_status

        if case_id:
            conditions.append("r.case_id = :case_id")
            params["case_id"] = case_id

        if assigned_to_me or assigned_analyst_id:
            conditions.append("r.assigned_analyst_id = :assigned_analyst_id")
            params["assigned_analyst_id"] = assigned_analyst_id

        if rule_id:
            conditions.append("rm.rule_id = :rule_id")
            params["rule_id"] = rule_id

        where_clause = " AND ".join(conditions) if conditions else "1=1"

        cursor_obj: TransactionCursor | None = None
        if cursor:
            cursor_obj = TransactionCursor.decode(cursor)
            if cursor_obj:
                conditions.append("(t.transaction_timestamp, t.id) < (:cursor_ts, :cursor_tid)")
                params["cursor_ts"] = cursor_obj.transaction_timestamp
                params["cursor_tid"] = cursor_obj.id
                where_clause = " AND ".join(conditions)

        # Build query with appropriate joins
        # IMPORTANT: r.transaction_id references t.id (PK), not t.transaction_id (business key)
        # See schema header for detailed explanation of transaction IDs
        from_clause = "fraud_gov.transactions t"
        if needs_review_join:
            from_clause += " LEFT JOIN fraud_gov.transaction_reviews r ON r.transaction_id = t.id"
        if needs_rule_join:
            from_clause += (
                " INNER JOIN fraud_gov.transaction_rule_matches rm ON rm.transaction_id = t.id"  # noqa: E501
            )

        # Data query WITHOUT review columns (for simplicity, can add later if needed)
        columns_with_prefix = """
            t.id, t.transaction_id, t.evaluation_type, t.card_id, t.card_last4,
            t.card_network, t.transaction_amount, t.transaction_currency,
            t.merchant_id, t.merchant_category_code, t.decision,
            t.decision_reason, t.decision_score, t.ruleset_key, t.ruleset_id,
            t.ruleset_version, t.risk_level, t.transaction_context,
            t.velocity_snapshot, t.velocity_results, t.engine_metadata,
            t.transaction_timestamp, t.ingestion_timestamp, t.kafka_topic,
            t.kafka_partition, t.kafka_offset, t.source_message_id, t.trace_id,
            t.request_id, t.session_id, t.raw_payload, t.ingestion_source,
            t.created_at, t.updated_at"""

        data_query = f"""
            SELECT {columns_with_prefix}
            FROM {from_clause}
            WHERE {where_clause}
            ORDER BY t.transaction_timestamp DESC, t.id DESC
            LIMIT :limit
        """

        # Count query
        count_result = await self.session.execute(
            text(f"SELECT COUNT(*) FROM {from_clause} WHERE {where_clause}"),
            params,
        )
        total = count_result.scalar() or 0

        result = await self.session.execute(text(data_query), {**params, "limit": limit + 1})

        transactions = [self._row_to_dict(row) for row in result.fetchall()]

        next_cursor: str | None = None
        if len(transactions) > limit:
            transactions = transactions[:limit]
            last_txn = transactions[-1]
            # IMPORTANT: Cursor uses t.id (PK), not t.transaction_id (business key)
            next_cursor = TransactionCursor(
                timestamp=last_txn["transaction_timestamp"],
                id=last_txn["id"],
            ).encode()

        return transactions, next_cursor, total or 0

    async def upsert_transaction(self, transaction_data: dict[str, Any]) -> dict[str, Any] | None:
        """Insert or update a transaction (idempotent by composite key).

        Composite key: (transaction_id, evaluation_type, transaction_timestamp)
        On duplicate: update metadata fields (trace_id, raw_payload, etc.).
        Never modify business fields.
        """
        result = await self.session.execute(
            text("""
                INSERT INTO fraud_gov.transactions (
                    id, transaction_id, evaluation_type,
                    card_id, card_last4, card_network,
                    transaction_amount, transaction_currency, merchant_id, merchant_category_code,
                    decision, decision_reason, decision_score,
                    ruleset_key, ruleset_id, ruleset_version,
                    risk_level,
                    transaction_context, velocity_snapshot, velocity_results, engine_metadata,
                    transaction_timestamp, ingestion_timestamp,
                    kafka_topic, kafka_partition, kafka_offset, source_message_id,
                    trace_id, request_id, session_id,
                    raw_payload, ingestion_source
                ) VALUES (
                    gen_random_uuid(),
                    :transaction_id, :evaluation_type,
                    :card_id, :card_last4, :card_network,
                    :transaction_amount, :transaction_currency, :merchant_id,
                    :merchant_category_code,
                    :decision, :decision_reason, :decision_score,
                    :ruleset_key, :ruleset_id, :ruleset_version,
                    :risk_level,
                    :transaction_context, :velocity_snapshot, :velocity_results, :engine_metadata,
                    :transaction_timestamp, :ingestion_timestamp,
                    :kafka_topic, :kafka_partition, :kafka_offset, :source_message_id,
                    :trace_id, :request_id, :session_id,
                    :raw_payload, :ingestion_source
                )
                ON CONFLICT (transaction_id, evaluation_type, transaction_timestamp) DO UPDATE SET
                    trace_id = EXCLUDED.trace_id,
                    request_id = EXCLUDED.request_id,
                    session_id = EXCLUDED.session_id,
                    raw_payload = EXCLUDED.raw_payload,
                    transaction_context = EXCLUDED.transaction_context,
                    velocity_snapshot = EXCLUDED.velocity_snapshot,
                    velocity_results = EXCLUDED.velocity_results,
                    engine_metadata = EXCLUDED.engine_metadata,
                    kafka_topic = EXCLUDED.kafka_topic,
                    kafka_partition = EXCLUDED.kafka_partition,
                    kafka_offset = EXCLUDED.kafka_offset,
                    updated_at = NOW()
                RETURNING id
            """),
            {
                "transaction_id": transaction_data["transaction_id"],
                "evaluation_type": transaction_data.get("evaluation_type", "AUTH"),
                "card_id": transaction_data["card_id"],
                "card_last4": transaction_data.get("card_last4"),
                "card_network": transaction_data.get("card_network"),
                "transaction_amount": float(transaction_data["amount"]),
                "transaction_currency": transaction_data["currency"],
                "merchant_id": transaction_data.get("merchant_id"),
                "merchant_category_code": transaction_data.get("merchant_category_code")
                or transaction_data.get("mcc"),
                "decision": transaction_data["decision"],
                "decision_reason": transaction_data["decision_reason"],
                "decision_score": transaction_data.get("decision_score"),
                "ruleset_key": transaction_data.get("ruleset_key"),
                "ruleset_id": transaction_data.get("ruleset_id"),
                "ruleset_version": transaction_data.get("ruleset_version"),
                "risk_level": transaction_data.get("risk_level"),
                "transaction_context": transaction_data.get("transaction_context"),
                "velocity_snapshot": transaction_data.get("velocity_snapshot"),
                "velocity_results": transaction_data.get("velocity_results"),
                "engine_metadata": transaction_data.get("engine_metadata"),
                "transaction_timestamp": transaction_data["occurred_at"],
                "ingestion_timestamp": datetime.utcnow(),
                "kafka_topic": transaction_data.get("kafka_topic"),
                "kafka_partition": transaction_data.get("kafka_partition"),
                "kafka_offset": transaction_data.get("kafka_offset"),
                "source_message_id": transaction_data.get("source_message_id"),
                "trace_id": transaction_data.get("trace_id"),
                "request_id": transaction_data.get("request_id"),
                "session_id": transaction_data.get("session_id"),
                "raw_payload": transaction_data.get("raw_payload"),
                "ingestion_source": transaction_data.get("ingestion_source", "HTTP"),
            },
        )
        result.fetchone()
        return await self.get_by_transaction_id(
            transaction_data["transaction_id"], transaction_data.get("evaluation_type", "AUTH")
        )

    async def add_rule_match(self, transaction_id: UUID, rule_match_data: dict[str, Any]) -> None:
        """Add a rule match to a transaction (idempotent by composite key)."""
        await self.session.execute(
            text("""
                INSERT INTO fraud_gov.transaction_rule_matches (
                    transaction_id, rule_id, rule_version_id, rule_version, rule_name,
                    rule_action, matched, contributing, rule_output,
                    conditions_met, condition_values,
                    match_score, match_reason, evaluated_at
                ) VALUES (
                    :transaction_id, :rule_id, :rule_version_id, :rule_version, :rule_name,
                    :rule_action, TRUE, TRUE, :rule_output,
                    :conditions_met, :condition_values,
                    :match_score, :match_reason, NOW()
                )
                ON CONFLICT (transaction_id, rule_id, rule_version) DO UPDATE SET
                    matched = EXCLUDED.matched,
                    contributing = EXCLUDED.contributing,
                    match_score = EXCLUDED.match_score,
                    conditions_met = EXCLUDED.conditions_met,
                    condition_values = EXCLUDED.condition_values
            """),
            {
                "transaction_id": transaction_id,
                "rule_id": str(rule_match_data["rule_id"]),
                "rule_version_id": rule_match_data.get("rule_version_id"),
                "rule_version": rule_match_data.get("rule_version"),
                "rule_name": rule_match_data.get("rule_name"),
                "rule_action": rule_match_data.get("rule_action"),
                "rule_output": rule_match_data.get("rule_output"),
                "conditions_met": rule_match_data.get("conditions_met"),
                "condition_values": rule_match_data.get("condition_values"),
                "match_score": rule_match_data.get("priority"),
                "match_reason": rule_match_data.get("match_reason"),
            },
        )

    async def get_rule_matches_for_event(self, transaction_event_id: UUID) -> list[dict[str, Any]]:
        """Get rule matches for a specific transaction event (transactions.id)."""
        result = await self.session.execute(
            text("""
                SELECT id, transaction_id, rule_id, rule_version_id, rule_version, rule_name,
                       matched, contributing, rule_output, match_score, match_reason, evaluated_at
                FROM fraud_gov.transaction_rule_matches
                WHERE transaction_id = :transaction_id
                ORDER BY evaluated_at ASC
            """),
            {"transaction_id": transaction_event_id},
        )
        return [self._rule_match_row_to_dict(row) for row in result.fetchall()]

    async def get_transaction_overview(
        self,
        transaction_id: UUID,
        include_rules: bool = False,
        analyst_id: str | None = None,
    ) -> dict[str, Any] | None:
        """Get combined transaction overview for analyst UI.

        Returns transaction, review, notes, case, and matched_rules in a single call.
        This is optimized for UI performance - one query instead of multiple.
        """
        # Get transaction
        transaction = await self.get_by_transaction_id(transaction_id)
        if transaction is None:
            return None

        # Get review (if exists)
        review = None
        review_result = await self.session.execute(
            text("""
                SELECT id, status, priority, assigned_analyst_id, assigned_at,
                       case_id, resolved_at, resolved_by, resolution_code, resolution_notes,
                       escalated_at, escalated_to, escalation_reason,
                       first_reviewed_at, last_activity_at, created_at, updated_at
                FROM fraud_gov.transaction_reviews
                WHERE transaction_id = :txn_id
            """),
            {"txn_id": transaction_id},
        )
        review_row = review_result.fetchone()
        if review_row:
            review = {
                "id": review_row[0],
                "status": review_row[1],
                "priority": review_row[2],
                "assigned_analyst_id": review_row[3],
                "assigned_at": review_row[4],
                "case_id": review_row[5],
                "resolved_at": review_row[6],
                "resolved_by": review_row[7],
                "resolution_code": review_row[8],
                "resolution_notes": review_row[9],
                "escalated_at": review_row[10],
                "escalated_to": review_row[11],
                "escalation_reason": review_row[12],
                "first_reviewed_at": review_row[13],
                "last_activity_at": review_row[14],
                "created_at": review_row[15],
                "updated_at": review_row[16],
            }

        # Get notes (respecting privacy)
        notes = []
        notes_params = {"txn_id": transaction_id}
        notes_query = """
            SELECT id, note_type, note_content, analyst_id, analyst_name,
                   analyst_email, is_private, is_system_generated, created_at
            FROM fraud_gov.analyst_notes
            WHERE transaction_id = :txn_id
        """
        if analyst_id:
            notes_query += " AND (is_private = FALSE OR analyst_id = :analyst_id)"
            notes_params["analyst_id"] = analyst_id
        else:
            notes_query += " AND is_private = FALSE"
        notes_query += " ORDER BY created_at DESC LIMIT 100"

        notes_result = await self.session.execute(text(notes_query), notes_params)
        for row in notes_result.fetchall():
            notes.append(
                {
                    "id": row[0],
                    "note_type": row[1],
                    "note_content": row[2],
                    "analyst_id": row[3],
                    "analyst_name": row[4],
                    "analyst_email": row[5],
                    "is_private": row[6],
                    "is_system_generated": row[7],
                    "created_at": row[8],
                }
            )

        # Get case (if linked via review)
        case = None
        case_id = review.get("case_id") if review else None
        if case_id:
            try:
                case_result = await self.session.execute(
                    text("""
                        SELECT id, case_number, case_type, case_status,
                               assigned_analyst_id, title, description,
                               total_transaction_count, total_transaction_amount,
                               risk_level, created_at, updated_at
                        FROM fraud_gov.transaction_cases
                        WHERE id = :case_id
                    """),
                    {"case_id": case_id},
                )
                case_row = case_result.fetchone()
                if case_row:
                    case = {
                        "case_id": case_row[0],
                        "case_number": case_row[1],
                        "case_type": case_row[2],
                        "case_status": case_row[3],
                        "assigned_analyst_id": case_row[4],
                        "title": case_row[5],
                        "description": case_row[6],
                        "total_transaction_count": case_row[7],
                        "total_transaction_amount": float(case_row[8]) if case_row[8] else 0,
                        "risk_level": case_row[9],
                        "created_at": case_row[10],
                        "updated_at": case_row[11],
                    }
            except Exception:
                pass  # Case might not exist

        # Get matched rules if requested
        matched_rules = []
        if include_rules:
            matched_rules = await self.get_rule_matches_for_event(UUID(transaction["id"]))

        # Calculate last_activity_at
        last_activity_at = transaction.get("updated_at")
        if review and review.get("last_activity_at"):
            if last_activity_at is None or review["last_activity_at"] > last_activity_at:
                last_activity_at = review["last_activity_at"]
        if notes:
            if last_activity_at is None or notes[0]["created_at"] > last_activity_at:
                last_activity_at = notes[0]["created_at"]
        if case and case.get("updated_at"):
            if last_activity_at is None or case["updated_at"] > last_activity_at:
                last_activity_at = case["updated_at"]

        return {
            "transaction": transaction,
            "review": review,
            "notes": notes,
            "case": case,
            "matched_rules": matched_rules,
            "last_activity_at": last_activity_at,
        }

    async def get_metrics(
        self, from_date: datetime | None = None, to_date: datetime | None = None
    ) -> dict[str, Any]:
        """Get transaction metrics."""
        conditions = []
        params: dict[str, Any] = {}

        if from_date:
            conditions.append("transaction_timestamp >= :from_date")
            params["from_date"] = from_date

        if to_date:
            conditions.append("transaction_timestamp <= :to_date")
            params["to_date"] = to_date

        where_clause = f"WHERE {' AND '.join(conditions)}" if conditions else ""

        result = await self.session.execute(
            text(f"""
                SELECT
                    COUNT(*) AS total_transactions,
                    COUNT(*) FILTER (WHERE decision = 'APPROVE') AS approved_count,
                    COUNT(*) FILTER (WHERE decision = 'DECLINE') AS declined_count,
                    COUNT(*) FILTER (WHERE evaluation_type = 'AUTH') AS auth_count,
                    COUNT(*) FILTER (WHERE evaluation_type = 'MONITORING') AS monitoring_count,
                    SUM(transaction_amount) AS total_amount,
                    AVG(transaction_amount) AS avg_amount
                FROM fraud_gov.transactions
                {where_clause}
            """),
            params,
        )

        row = result.fetchone()
        if row is None:
            return {
                "total_transactions": 0,
                "approved_count": 0,
                "declined_count": 0,
                "auth_count": 0,
                "monitoring_count": 0,
                "total_amount": 0.0,
                "avg_amount": 0.0,
            }
        return {
            "total_transactions": row[0] or 0,
            "approved_count": row[1] or 0,
            "declined_count": row[2] or 0,
            "auth_count": row[3] or 0,
            "monitoring_count": row[4] or 0,
            "total_amount": float(row[5]) if row[5] else 0,
            "avg_amount": float(row[6]) if row[6] else 0,
        }

    def _row_to_dict(self, row) -> dict[str, Any]:
        """Convert a database row to a dictionary."""
        return {
            "id": str(row[0]) if row[0] is not None else None,
            "transaction_id": str(row[1]) if row[1] is not None else None,
            "evaluation_type": row[2],
            "card_id": row[3],
            "card_last4": row[4],
            "card_network": row[5],
            "amount": float(row[6]),
            "currency": row[7],
            "merchant_id": row[8],
            "mcc": row[9],
            "decision": row[10],
            "decision_reason": row[11],
            "decision_score": float(row[12]) if row[12] else None,
            "ruleset_key": row[13],
            "ruleset_id": str(row[14]) if row[14] is not None else None,
            "ruleset_version": row[15],
            "risk_level": row[16],
            "transaction_context": row[17],
            "velocity_snapshot": row[18],
            "velocity_results": row[19],
            "engine_metadata": row[20],
            "transaction_timestamp": row[21],
            "ingestion_timestamp": row[22],
            "kafka_topic": row[23],
            "kafka_partition": row[24],
            "kafka_offset": row[25],
            "source_message_id": row[26],
            "trace_id": row[27],
            "request_id": row[28],
            "session_id": row[29],
            "raw_payload": row[30],
            "ingestion_source": row[31],
            "created_at": row[32],
            "updated_at": row[33],
            "matched_rules": [],
        }

    def _row_to_dict_with_review(self, row) -> dict[str, Any]:
        """Convert a database row with review info to a dictionary."""
        return {
            "id": str(row[0]) if row[0] is not None else None,
            "transaction_id": str(row[1]) if row[1] is not None else None,
            "evaluation_type": row[2],
            "card_id": row[3],
            "card_last4": row[4],
            "card_network": row[5],
            "amount": float(row[6]),
            "currency": row[7],
            "merchant_id": row[8],
            "mcc": row[9],
            "decision": row[10],
            "decision_reason": row[11],
            "decision_score": float(row[12]) if row[12] else None,
            "ruleset_key": row[13],
            "ruleset_id": str(row[14]) if row[14] is not None else None,
            "ruleset_version": row[15],
            "risk_level": row[16],
            "transaction_context": row[17],
            "velocity_snapshot": row[18],
            "velocity_results": row[19],
            "engine_metadata": row[20],
            "transaction_timestamp": row[21],
            "ingestion_timestamp": row[22],
            "kafka_topic": row[23],
            "kafka_partition": row[24],
            "kafka_offset": row[25],
            "source_message_id": row[26],
            "trace_id": row[27],
            "request_id": row[28],
            "session_id": row[29],
            "raw_payload": row[30],
            "ingestion_source": row[31],
            "created_at": row[32],
            "updated_at": row[33],
            "matched_rules": [],
            "review_status": row[34],
            "review_priority": row[35],
            "review_assigned_analyst_id": row[36],
            "review_case_id": row[37],
        }

    def _rule_match_row_to_dict(self, row) -> dict[str, Any]:
        """Convert a rule match row to a dictionary."""
        return {
            "id": row[0],
            "transaction_id": str(row[1]) if row[1] is not None else None,
            "rule_id": str(row[2]) if row[2] is not None else None,
            "rule_version_id": str(row[3]) if row[3] is not None else None,
            "rule_version": row[4],
            "rule_name": row[5],
            "matched": row[6],
            "contributing": row[7],
            "rule_output": row[8],
            "match_score": float(row[9]) if row[9] else None,
            "match_reason": row[10],
            "matched_at": row[11],
        }

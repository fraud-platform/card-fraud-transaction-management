-- Card Fraud Transaction Management — Database Schema
-- Schema: fraud_gov (shared with card-fraud-rule-management)
--
-- Tables:
--   - fraud_gov.transactions: Core decision event data
--   - fraud_gov.transaction_rule_matches: Rule match records per transaction
--   - fraud_gov.transaction_reviews: Analyst review workflow
--   - fraud_gov.analyst_notes: Notes on transactions
--   - fraud_gov.transaction_cases: Cases for grouping related transactions
--   - fraud_gov.case_activity_log: Case audit trail
--
-- Design Principles:
--   1. Immutable core — transactions are append-only decision events
--   2. Lean hot table — no volatile fraud features
--   3. Clear lineage — Kafka offsets + trace IDs are first-class
--   4. Audit-first — time semantics are explicit and indexed
--   5. Future-safe — extensibility planned, not prematurely implemented
--
-- ================================================================================
-- IMPORTANT: Understanding transaction IDs
-- ================================================================================
--
-- The transactions table has TWO UUID columns with DIFFERENT purposes:
--
--   1. id (PK)           = Surrogate primary key, uniquely identifies THIS DATABASE ROW
--                         Generated by Transaction Management app (UUIDv7)
--                         Used for foreign key references in child tables
--
--   2. transaction_id    = Business transaction ID from Rule Engine / payment system
--                         Passed through from Rule Engine (UUIDv7)
--                         Used for idempotency and business lookups
--
-- Example of same business transaction with TWO events:
--
--   | id (PK)            | transaction_id    | evaluation_type |
--   |--------------------|-------------------|-----------------|
--   | 01234567-...       | abc-123-def       | AUTH         |
--   | 76543210-...       | abc-123-def       | MONITORING        |
--
-- The UNIQUE constraint (transaction_id, evaluation_type, transaction_timestamp)
-- allows both AUTH and MONITORING events for the same transaction_id.
--
-- FOREIGN KEY REFERENCE PATTERN:
--   Child tables (transaction_reviews, transaction_rule_matches, etc.)
--   have `transaction_id UUID NOT NULL REFERENCES fraud_gov.transactions(id)`
--
--   This means child.transaction_id → parent.id (the PK), NOT parent.transaction_id!
--
--   CORRECT JOIN:   FROM transaction_reviews r JOIN transactions t ON r.transaction_id = t.id
--   WRONG JOIN:     FROM transaction_reviews r JOIN transactions t ON r.transaction_id = t.transaction_id
--
-- ================================================================================
--
-- Run: doppler run --config local -- uv run db-init
--
-- ============================================================================
-- TYPES (idempotent using DO $$ pattern)
-- ============================================================================

DO $$
BEGIN
  -- Original types
  IF NOT EXISTS (SELECT 1 FROM pg_type t JOIN pg_namespace n ON n.oid=t.typnamespace
                 WHERE t.typname='decision_type' AND n.nspname='fraud_gov') THEN
    CREATE TYPE fraud_gov.decision_type AS ENUM ('APPROVE', 'DECLINE');
    COMMENT ON TYPE fraud_gov.decision_type IS
        'Transaction decision: APPROVE/DECLINE (engine decision outcome only)';
  END IF;

  -- Evaluation type: distinguishes AUTH (real-time) from MONITORING (analytics-only)
  IF NOT EXISTS (SELECT 1 FROM pg_type t JOIN pg_namespace n ON n.oid=t.typnamespace
                 WHERE t.typname='evaluation_type' AND n.nspname='fraud_gov') THEN
    CREATE TYPE fraud_gov.evaluation_type AS ENUM ('AUTH', 'MONITORING');
    COMMENT ON TYPE fraud_gov.evaluation_type IS
        'Evaluation type: AUTH (real-time decision), MONITORING (post-auth analytics)';
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_type t JOIN pg_namespace n ON n.oid=t.typnamespace
                 WHERE t.typname='decision_reason' AND n.nspname='fraud_gov') THEN
    CREATE TYPE fraud_gov.decision_reason AS ENUM (
        'RULE_MATCH', 'VELOCITY_MATCH', 'SYSTEM_DECLINE', 'DEFAULT_ALLOW', 'MANUAL_REVIEW'
    );
    COMMENT ON TYPE fraud_gov.decision_reason IS 'Reason for decision outcome';
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_type t JOIN pg_namespace n ON n.oid=t.typnamespace
                 WHERE t.typname='card_network' AND n.nspname='fraud_gov') THEN
    CREATE TYPE fraud_gov.card_network AS ENUM ('VISA', 'MASTERCARD', 'AMEX', 'DISCOVER', 'OTHER');
    COMMENT ON TYPE fraud_gov.card_network IS 'Card network/brand';
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_type t JOIN pg_namespace n ON n.oid=t.typnamespace
                 WHERE t.typname='ingestion_source' AND n.nspname='fraud_gov') THEN
    CREATE TYPE fraud_gov.ingestion_source AS ENUM ('HTTP', 'KAFKA');
    COMMENT ON TYPE fraud_gov.ingestion_source IS 'How the decision event was ingested';
  END IF;

  -- New types for analyst workflow
  IF NOT EXISTS (SELECT 1 FROM pg_type t JOIN pg_namespace n ON n.oid=t.typnamespace
                 WHERE t.typname='transaction_status' AND n.nspname='fraud_gov') THEN
    CREATE TYPE fraud_gov.transaction_status AS ENUM (
        'PENDING', 'IN_REVIEW', 'ESCALATED', 'RESOLVED', 'CLOSED'
    );
    COMMENT ON TYPE fraud_gov.transaction_status IS
        'Analyst review workflow status for transactions';
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_type t JOIN pg_namespace n ON n.oid=t.typnamespace
                 WHERE t.typname='risk_level' AND n.nspname='fraud_gov') THEN
    CREATE TYPE fraud_gov.risk_level AS ENUM ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL');
    COMMENT ON TYPE fraud_gov.risk_level IS 'Risk level classification for fraud analysis';
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_type t JOIN pg_namespace n ON n.oid=t.typnamespace
                 WHERE t.typname='note_type' AND n.nspname='fraud_gov') THEN
    CREATE TYPE fraud_gov.note_type AS ENUM (
        'GENERAL', 'INITIAL_REVIEW', 'CUSTOMER_CONTACT', 'MERCHANT_CONTACT',
        'BANK_CONTACT', 'FRAUD_CONFIRMED', 'FALSE_POSITIVE', 'ESCALATION',
        'RESOLUTION', 'LEGAL_HOLD', 'INTERNAL_REVIEW'
    );
    COMMENT ON TYPE fraud_gov.note_type IS 'Type of analyst note for classification';
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_type t JOIN pg_namespace n ON n.oid=t.typnamespace
                 WHERE t.typname='case_type' AND n.nspname='fraud_gov') THEN
    CREATE TYPE fraud_gov.case_type AS ENUM (
        'INVESTIGATION', 'DISPUTE', 'CHARGEBACK', 'FRAUD_RING',
        'ACCOUNT_TAKEOVER', 'PATTERN_ANALYSIS', 'MERCHANT_REVIEW',
        'CARD_COMPROMISE', 'OTHER'
    );
    COMMENT ON TYPE fraud_gov.case_type IS 'Type of case for grouping related transactions';
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_type t JOIN pg_namespace n ON n.oid=t.typnamespace
                 WHERE t.typname='case_status' AND n.nspname='fraud_gov') THEN
    CREATE TYPE fraud_gov.case_status AS ENUM (
        'OPEN', 'IN_PROGRESS', 'PENDING_INFO', 'RESOLVED', 'CLOSED'
    );
    COMMENT ON TYPE fraud_gov.case_status IS 'Status of case workflow';
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_type t JOIN pg_namespace n ON n.oid=t.typnamespace
                 WHERE t.typname='rule_action' AND n.nspname='fraud_gov') THEN
    CREATE TYPE fraud_gov.rule_action AS ENUM ('APPROVE', 'DECLINE', 'REVIEW');
    COMMENT ON TYPE fraud_gov.rule_action IS 'Action taken by a matched rule';
  END IF;
END $$;

-- ============================================================================
-- TABLES
-- ============================================================================

-- Core transactions table
CREATE TABLE IF NOT EXISTS fraud_gov.transactions (
    -- Primary key (UUID v7 generated by Transaction Management app)
    -- Used as FK target in child tables (see schema header for details)
    id UUID NOT NULL PRIMARY KEY,

    -- Business transaction ID from Rule Engine (UUIDv7)
    -- Used for idempotency and business lookups
    -- See UNIQUE constraint below for how AUTH/MONITORING are handled
    transaction_id UUID NOT NULL,
    evaluation_type fraud_gov.evaluation_type NOT NULL,

    -- Card identification (tokenized for PCI)
    card_id VARCHAR(64) NOT NULL,
    card_last4 VARCHAR(4),
    card_network fraud_gov.card_network,

    -- Transaction details
    transaction_amount DECIMAL(19,4) NOT NULL,
    transaction_currency VARCHAR(3) NOT NULL DEFAULT 'USD',
    merchant_id VARCHAR(64),
    merchant_category_code VARCHAR(8),

    -- Decision (engine outcome only - APPROVE/DECLINE)
    decision fraud_gov.decision_type NOT NULL,
    decision_reason fraud_gov.decision_reason NOT NULL,
    decision_score DECIMAL(5,2),

    -- Risk classification
    risk_level fraud_gov.risk_level,

    -- Ruleset metadata
    ruleset_key VARCHAR(128),
    ruleset_id UUID,
    ruleset_version INTEGER,

    -- Extended context (JSONB for flexible schema evolution)
    transaction_context JSONB,
    velocity_snapshot JSONB,
    velocity_results JSONB,
    engine_metadata JSONB,

    -- Temporal (UTC)
    transaction_timestamp TIMESTAMPTZ NOT NULL,
    ingestion_timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- Kafka lineage (production)
    kafka_topic VARCHAR(256),
    kafka_partition INTEGER,
    kafka_offset BIGINT,
    source_message_id VARCHAR(256),

    -- Request/response context
    trace_id VARCHAR(64),
    request_id VARCHAR(64),
    session_id VARCHAR(64),

    -- Raw payload (strictly allowlist-only, PCI-redacted)
    raw_payload JSONB,

    -- Operational
    ingestion_source fraud_gov.ingestion_source NOT NULL DEFAULT 'HTTP',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- Unique constraint for composite idempotency key
    CONSTRAINT uk_transaction_idempotency UNIQUE (transaction_id, evaluation_type, transaction_timestamp)
);

-- Rule matches per transaction (enhanced with new columns)
CREATE TABLE IF NOT EXISTS fraud_gov.transaction_rule_matches (
    id SERIAL PRIMARY KEY,
    -- FK references transactions.id (PK), NOT transactions.transaction_id
    transaction_id UUID NOT NULL REFERENCES fraud_gov.transactions(id) ON DELETE CASCADE,

    rule_id UUID NOT NULL,
    rule_version_id UUID,
    rule_version INTEGER,
    rule_name VARCHAR(128) NOT NULL,

    -- Rule action
    rule_action fraud_gov.rule_action,

    -- Rule outcome in this context
    matched BOOLEAN NOT NULL DEFAULT FALSE,
    contributing BOOLEAN NOT NULL DEFAULT FALSE,
    rule_output JSONB,

    -- Condition details (JSONB for flexible condition representation)
    conditions_met JSONB,
    condition_values JSONB,

    -- Match details
    match_score DECIMAL(5,2),
    match_reason VARCHAR(256),

    -- Timing
    evaluated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- Composite unique constraint for idempotency (prefer rule_version_id if present)
    CONSTRAINT uk_transaction_rule_match UNIQUE (transaction_id, rule_id, rule_version)
);

-- Transaction reviews table (analyst workflow)
CREATE TABLE IF NOT EXISTS fraud_gov.transaction_reviews (
    -- Primary key
    id UUID NOT NULL PRIMARY KEY,

    -- FK references transactions.id (PK), NOT transactions.transaction_id
    -- This is the surrogate PK, not the business transaction_id
    transaction_id UUID NOT NULL REFERENCES fraud_gov.transactions(id) ON DELETE CASCADE,

    -- Review status
    status fraud_gov.transaction_status NOT NULL DEFAULT 'PENDING',

    -- Assignment
    assigned_analyst_id VARCHAR(128),
    assigned_at TIMESTAMPTZ,

    -- Priority (1=highest, 5=lowest)
    priority INTEGER NOT NULL DEFAULT 3,

    -- Case linkage
    case_id UUID,

    -- Resolution details
    resolved_at TIMESTAMPTZ,
    resolved_by VARCHAR(128),
    resolution_code VARCHAR(64),
    resolution_notes TEXT,

    -- Escalation details
    escalated_at TIMESTAMPTZ,
    escalated_to VARCHAR(128),
    escalation_reason TEXT,

    -- Review timestamps
    first_reviewed_at TIMESTAMPTZ,
    last_activity_at TIMESTAMPTZ,

    -- Metadata
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- Ensure one review per transaction
    CONSTRAINT uk_transaction_review UNIQUE (transaction_id)
);

-- Analyst notes table
CREATE TABLE IF NOT EXISTS fraud_gov.analyst_notes (
    -- Primary key
    id UUID NOT NULL PRIMARY KEY,

    -- FK references transactions.id (PK), NOT transactions.transaction_id
    transaction_id UUID NOT NULL REFERENCES fraud_gov.transactions(id) ON DELETE CASCADE,

    -- Note classification
    note_type fraud_gov.note_type NOT NULL DEFAULT 'GENERAL',

    -- Note content
    note_content TEXT NOT NULL,

    -- Author
    analyst_id VARCHAR(128) NOT NULL,
    analyst_name VARCHAR(256),
    analyst_email VARCHAR(256),

    -- Visibility
    is_private BOOLEAN NOT NULL DEFAULT FALSE,
    is_system_generated BOOLEAN NOT NULL DEFAULT FALSE,

    -- Case linkage (optional)
    case_id UUID,

    -- Timestamps
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Transaction cases table (for grouping related transactions)
CREATE TABLE IF NOT EXISTS fraud_gov.transaction_cases (
    -- Primary key
    id UUID NOT NULL PRIMARY KEY,

    -- Human-readable case number (auto-generated)
    case_number VARCHAR(64) NOT NULL UNIQUE,

    -- Case classification
    case_type fraud_gov.case_type NOT NULL,
    case_status fraud_gov.case_status NOT NULL DEFAULT 'OPEN',

    -- Assignment
    assigned_analyst_id VARCHAR(128),
    assigned_at TIMESTAMPTZ,

    -- Case details
    title VARCHAR(512) NOT NULL,
    description TEXT,

    -- Aggregates (denormalized for performance)
    total_transaction_count INTEGER NOT NULL DEFAULT 0,
    total_transaction_amount DECIMAL(19,4) NOT NULL DEFAULT 0,

    -- Risk summary
    risk_level fraud_gov.risk_level,

    -- Resolution details
    resolved_at TIMESTAMPTZ,
    resolved_by VARCHAR(128),
    resolution_summary TEXT,

    -- Timestamps
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    closed_at TIMESTAMPTZ
);

-- Case activity log (audit trail)
CREATE TABLE IF NOT EXISTS fraud_gov.case_activity_log (
    -- Primary key
    id SERIAL PRIMARY KEY,

    -- Case reference
    case_id UUID NOT NULL REFERENCES fraud_gov.transaction_cases(id) ON DELETE CASCADE,

    -- Activity details
    activity_type VARCHAR(64) NOT NULL,
    activity_description TEXT NOT NULL,

    -- Actor
    analyst_id VARCHAR(128),
    analyst_name VARCHAR(256),

    -- Change details (JSONB for flexible representation)
    old_values JSONB,
    new_values JSONB,

    -- Transaction reference (if activity relates to specific transaction)
    -- References transactions.id (PK), no FK constraint to allow historical references
    transaction_id UUID,

    -- Timestamp
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ============================================================================
-- INDEXES (Fraud Operations Focus)
-- ============================================================================

-- Primary lookup patterns (hot paths)
CREATE INDEX IF NOT EXISTS idx_transactions_card_id ON fraud_gov.transactions(card_id);
CREATE INDEX IF NOT EXISTS idx_transactions_timestamp ON fraud_gov.transactions(transaction_timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_transactions_decision ON fraud_gov.transactions(decision, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_transactions_evaluation_type ON fraud_gov.transactions(evaluation_type, transaction_timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_transactions_ruleset ON fraud_gov.transactions(ruleset_key, ruleset_id, ruleset_version);
CREATE INDEX IF NOT EXISTS idx_transactions_idempotency ON fraud_gov.transactions(transaction_id, evaluation_type, transaction_timestamp);

-- Risk-based queries
CREATE INDEX IF NOT EXISTS idx_transactions_risk_level ON fraud_gov.transactions(risk_level, transaction_timestamp DESC)
    WHERE risk_level IS NOT NULL;

-- Fraud analysis patterns (cool paths)
CREATE INDEX IF NOT EXISTS idx_transactions_trace ON fraud_gov.transactions(trace_id);
CREATE INDEX IF NOT EXISTS idx_transactions_kafka_offset ON fraud_gov.transactions(kafka_topic, kafka_partition, kafka_offset);
CREATE INDEX IF NOT EXISTS idx_transactions_amount_high ON fraud_gov.transactions(transaction_amount DESC)
    WHERE transaction_amount > 10000;

-- JSONB GIN indexes for flexible querying
CREATE INDEX IF NOT EXISTS idx_transactions_context_gin ON fraud_gov.transactions USING GIN (transaction_context)
    WHERE transaction_context IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_transactions_velocity_gin ON fraud_gov.transactions USING GIN (velocity_snapshot)
    WHERE velocity_snapshot IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_transactions_velocity_results_gin ON fraud_gov.transactions USING GIN (velocity_results)
    WHERE velocity_results IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_transactions_metadata_gin ON fraud_gov.transactions USING GIN (engine_metadata)
    WHERE engine_metadata IS NOT NULL;

-- Rule match patterns
CREATE INDEX IF NOT EXISTS idx_rule_matches_transaction ON fraud_gov.transaction_rule_matches(transaction_id);
CREATE INDEX IF NOT EXISTS idx_rule_matches_rule ON fraud_gov.transaction_rule_matches(rule_id, rule_version);
CREATE INDEX IF NOT EXISTS idx_rule_matches_rule_id ON fraud_gov.transaction_rule_matches(rule_id);
CREATE INDEX IF NOT EXISTS idx_rule_matches_contributing ON fraud_gov.transaction_rule_matches(contributing, matched)
    WHERE matched = TRUE AND contributing = TRUE;

-- Transaction review indexes
CREATE INDEX IF NOT EXISTS idx_reviews_transaction ON fraud_gov.transaction_reviews(transaction_id);
CREATE INDEX IF NOT EXISTS idx_reviews_status ON fraud_gov.transaction_reviews(status, priority ASC, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_reviews_analyst ON fraud_gov.transaction_reviews(assigned_analyst_id, status)
    WHERE assigned_analyst_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_reviews_assigned_priority ON fraud_gov.transaction_reviews(assigned_analyst_id, priority, created_at DESC)
    WHERE assigned_analyst_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_reviews_case ON fraud_gov.transaction_reviews(case_id)
    WHERE case_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_reviews_unassigned ON fraud_gov.transaction_reviews(status, priority ASC, created_at DESC)
    WHERE assigned_analyst_id IS NULL AND status IN ('PENDING', 'IN_REVIEW', 'ESCALATED');

-- Analyst notes indexes
CREATE INDEX IF NOT EXISTS idx_notes_transaction ON fraud_gov.analyst_notes(transaction_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_notes_analyst ON fraud_gov.analyst_notes(analyst_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_notes_type ON fraud_gov.analyst_notes(note_type, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_notes_case ON fraud_gov.analyst_notes(case_id)
    WHERE case_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_notes_private ON fraud_gov.analyst_notes(analyst_id, is_private)
    WHERE is_private = TRUE;

-- Transaction cases indexes
CREATE INDEX IF NOT EXISTS idx_cases_number ON fraud_gov.transaction_cases(case_number);
CREATE INDEX IF NOT EXISTS idx_cases_status ON fraud_gov.transaction_cases(case_status, case_type, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_cases_analyst ON fraud_gov.transaction_cases(assigned_analyst_id, case_status)
    WHERE assigned_analyst_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_cases_risk ON fraud_gov.transaction_cases(risk_level, case_status)
    WHERE risk_level IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_cases_type ON fraud_gov.transaction_cases(case_type, created_at DESC);

-- Case activity log indexes
CREATE INDEX IF NOT EXISTS idx_activity_case ON fraud_gov.case_activity_log(case_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_activity_transaction ON fraud_gov.case_activity_log(transaction_id)
    WHERE transaction_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_activity_analyst ON fraud_gov.case_activity_log(analyst_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_activity_type ON fraud_gov.case_activity_log(activity_type, created_at DESC);

-- ============================================================================
-- SEQUENCES
-- ============================================================================

-- Sequence for case_number generation
CREATE SEQUENCE IF NOT EXISTS fraud_gov.case_number_seq
    START WITH 1000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;

-- ============================================================================
-- FUNCTIONS
-- ============================================================================

-- Auto-update updated_at
CREATE OR REPLACE FUNCTION fraud_gov.update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Generate next case number
CREATE OR REPLACE FUNCTION fraud_gov.generate_case_number()
RETURNS VARCHAR(64) AS $$
DECLARE
    next_num BIGINT;
BEGIN
    next_num := nextval('fraud_gov.case_number_seq');
    RETURN 'FC-' || TO_CHAR(CURRENT_DATE, 'YYYYMMDD') || '-' || LPAD(next_num::TEXT, 6, '0');
END;
$$ LANGUAGE plpgsql;

-- Update case aggregates when transactions are linked/unlinked
CREATE OR REPLACE FUNCTION fraud_gov.update_case_aggregates()
RETURNS TRIGGER AS $$
DECLARE
    txn_amount NUMERIC;
BEGIN
    IF TG_OP = 'INSERT' THEN
        IF NEW.case_id IS NULL THEN
            RETURN NEW;
        END IF;
        -- Get transaction amount from transactions table
        SELECT transaction_amount INTO txn_amount
        FROM fraud_gov.transactions
        WHERE id = NEW.transaction_id;

        UPDATE fraud_gov.transaction_cases
        SET total_transaction_count = total_transaction_count + 1,
            total_transaction_amount = total_transaction_amount + COALESCE(txn_amount, 0),
            updated_at = NOW()
        WHERE id = NEW.case_id;
        RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        IF OLD.case_id IS DISTINCT FROM NEW.case_id THEN
            -- Get transaction amount
            SELECT transaction_amount INTO txn_amount
            FROM fraud_gov.transactions
            WHERE id = NEW.transaction_id;

            -- Remove from old case
            IF OLD.case_id IS NOT NULL THEN
                UPDATE fraud_gov.transaction_cases
                SET total_transaction_count = GREATEST(total_transaction_count - 1, 0),
                    total_transaction_amount = GREATEST(total_transaction_amount - COALESCE(txn_amount, 0), 0),
                    updated_at = NOW()
                WHERE id = OLD.case_id;
            END IF;
            -- Add to new case
            IF NEW.case_id IS NOT NULL THEN
                UPDATE fraud_gov.transaction_cases
                SET total_transaction_count = total_transaction_count + 1,
                    total_transaction_amount = total_transaction_amount + COALESCE(txn_amount, 0),
                    updated_at = NOW()
                WHERE id = NEW.case_id;
            END IF;
        END IF;
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        IF OLD.case_id IS NULL THEN
            RETURN OLD;
        END IF;
        -- Get transaction amount
        SELECT transaction_amount INTO txn_amount
        FROM fraud_gov.transactions
        WHERE id = OLD.transaction_id;

        UPDATE fraud_gov.transaction_cases
        SET total_transaction_count = GREATEST(total_transaction_count - 1, 0),
            total_transaction_amount = GREATEST(total_transaction_amount - COALESCE(txn_amount, 0), 0),
            updated_at = NOW()
        WHERE id = OLD.case_id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Auto-create review record on transaction insert (AUTH only)
CREATE OR REPLACE FUNCTION fraud_gov.create_transaction_review()
RETURNS TRIGGER AS $$
BEGIN
    -- Only create review for AUTH evaluations (not MONITORING analytics)
    IF NEW.evaluation_type = 'AUTH' THEN
        INSERT INTO fraud_gov.transaction_reviews (
            id, transaction_id, status, priority, created_at, updated_at
        ) VALUES (
            gen_random_uuid(), NEW.id, 'PENDING',
            CASE
                WHEN NEW.risk_level = 'CRITICAL' THEN 1
                WHEN NEW.risk_level = 'HIGH' THEN 2
                WHEN NEW.risk_level = 'MEDIUM' THEN 3
                ELSE 4
            END,
            NOW(), NOW()
        )
        ON CONFLICT (transaction_id) DO NOTHING;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Update last_activity_at on review changes
CREATE OR REPLACE FUNCTION fraud_gov.update_review_activity()
RETURNS TRIGGER AS $$
BEGIN
    NEW.last_activity_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- TRIGGERS
-- ============================================================================

-- Transactions: updated_at trigger
DROP TRIGGER IF EXISTS trg_transactions_updated_at ON fraud_gov.transactions;
CREATE TRIGGER trg_transactions_updated_at
    BEFORE UPDATE ON fraud_gov.transactions
    FOR EACH ROW
    EXECUTE FUNCTION fraud_gov.update_updated_at();

-- Transactions: auto-create review (optional - only if decision requires review)
DROP TRIGGER IF EXISTS trg_transactions_auto_review ON fraud_gov.transactions;
-- Note: This trigger is disabled by default. Enable if auto-review creation is needed.
-- CREATE TRIGGER trg_transactions_auto_review
--     AFTER INSERT ON fraud_gov.transactions
--     FOR EACH ROW
--     EXECUTE FUNCTION fraud_gov.create_transaction_review();

-- Transaction reviews: updated_at trigger
DROP TRIGGER IF EXISTS trg_reviews_updated_at ON fraud_gov.transaction_reviews;
CREATE TRIGGER trg_reviews_updated_at
    BEFORE UPDATE ON fraud_gov.transaction_reviews
    FOR EACH ROW
    EXECUTE FUNCTION fraud_gov.update_updated_at();

-- Transaction reviews: last_activity_at trigger
DROP TRIGGER IF EXISTS trg_reviews_activity ON fraud_gov.transaction_reviews;
CREATE TRIGGER trg_reviews_activity
    BEFORE UPDATE ON fraud_gov.transaction_reviews
    FOR EACH ROW
    EXECUTE FUNCTION fraud_gov.update_review_activity();

-- Analyst notes: updated_at trigger
DROP TRIGGER IF EXISTS trg_notes_updated_at ON fraud_gov.analyst_notes;
CREATE TRIGGER trg_notes_updated_at
    BEFORE UPDATE ON fraud_gov.analyst_notes
    FOR EACH ROW
    EXECUTE FUNCTION fraud_gov.update_updated_at();

-- Transaction cases: updated_at trigger
DROP TRIGGER IF EXISTS trg_cases_updated_at ON fraud_gov.transaction_cases;
CREATE TRIGGER trg_cases_updated_at
    BEFORE UPDATE ON fraud_gov.transaction_cases
    FOR EACH ROW
    EXECUTE FUNCTION fraud_gov.update_updated_at();

-- Transaction reviews: update case aggregates on case_id change
DROP TRIGGER IF EXISTS trg_reviews_case_aggregates ON fraud_gov.transaction_reviews;
CREATE TRIGGER trg_reviews_case_aggregates
    AFTER INSERT OR UPDATE OR DELETE ON fraud_gov.transaction_reviews
    FOR EACH ROW
    EXECUTE FUNCTION fraud_gov.update_case_aggregates();

-- ============================================================================
-- COMMENTS
-- ============================================================================

COMMENT ON TABLE fraud_gov.transactions IS
    'Fraud decision events - immutable append-only core table';
COMMENT ON TABLE fraud_gov.transaction_rule_matches IS
    'Rule match records per transaction - for rule debugging and analysis';
COMMENT ON TABLE fraud_gov.transaction_reviews IS
    'Analyst review workflow for transactions - one per transaction';
COMMENT ON TABLE fraud_gov.analyst_notes IS
    'Notes added by analysts during transaction review';
COMMENT ON TABLE fraud_gov.transaction_cases IS
    'Cases for grouping related transactions for investigation';
COMMENT ON TABLE fraud_gov.case_activity_log IS
    'Audit trail for case activities';

COMMENT ON COLUMN fraud_gov.transactions.transaction_context IS
    'Full payload from rule engine with all evaluation context';
COMMENT ON COLUMN fraud_gov.transactions.velocity_snapshot IS
    'All velocity states at decision time for historical analysis';
COMMENT ON COLUMN fraud_gov.transactions.velocity_results IS
    'Per-rule velocity calculation results for matched rules';
COMMENT ON COLUMN fraud_gov.transactions.engine_metadata IS
    'Engine mode, processing time, errors, and other runtime metadata';
COMMENT ON COLUMN fraud_gov.transactions.evaluation_type IS
    'Evaluation type: AUTH (real-time decision), MONITORING (analytics-only)';
COMMENT ON COLUMN fraud_gov.transactions.ruleset_key IS
    'Ruleset key for ruleset identification';
COMMENT ON COLUMN fraud_gov.transactions.risk_level IS
    'Risk classification: LOW, MEDIUM, HIGH, CRITICAL';

COMMENT ON COLUMN fraud_gov.transaction_rule_matches.rule_version_id IS
    'UUID identifier for the specific rule version';
COMMENT ON COLUMN fraud_gov.transaction_rule_matches.rule_action IS
    'Action determined by the rule: APPROVE, DECLINE, REVIEW';
COMMENT ON COLUMN fraud_gov.transaction_rule_matches.conditions_met IS
    'Array of condition descriptions that matched';
COMMENT ON COLUMN fraud_gov.transaction_rule_matches.condition_values IS
    'Actual values evaluated for each condition';

COMMENT ON COLUMN fraud_gov.transaction_reviews.priority IS
    'Priority level: 1=highest, 5=lowest';
COMMENT ON COLUMN fraud_gov.transaction_reviews.resolution_code IS
    'Standardized resolution code (e.g., FRAUD_CONFIRMED, FALSE_POSITIVE, NEEDS_INFO)';

COMMENT ON INDEX fraud_gov.idx_transactions_card_id IS
    'Card-centric lookup for customer dispute investigation';
COMMENT ON INDEX fraud_gov.idx_transactions_timestamp IS
    'Time-series queries for dashboards and reporting';
COMMENT ON INDEX fraud_gov.idx_transactions_decision IS
    'Decision distribution for fraud rate monitoring';
COMMENT ON INDEX fraud_gov.idx_transactions_ruleset IS
    'Ruleset-version performance comparison';
COMMENT ON INDEX fraud_gov.idx_transactions_trace IS
    'Distributed trace correlation';
COMMENT ON INDEX fraud_gov.idx_transactions_kafka_offset IS
    'Kafka consumer lag monitoring and replay';
COMMENT ON INDEX fraud_gov.idx_reviews_unassigned IS
    'Quick lookup for unassigned transactions requiring review';

-- ============================================================================
-- GRANTS
-- ============================================================================
-- Grant permissions on tables to the application user
DO $$
BEGIN
    -- Grant SELECT, INSERT, UPDATE on transactions table
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.role_table_grants
        WHERE table_schema = 'fraud_gov'
        AND table_name = 'transactions'
        AND grantee = current_user
        AND privilege_type = 'SELECT'
    ) THEN
        GRANT SELECT, INSERT, UPDATE ON fraud_gov.transactions TO fraud_gov_app_user;
    END IF;

    -- Grant SELECT, INSERT, UPDATE, DELETE on transaction_rule_matches table
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.role_table_grants
        WHERE table_schema = 'fraud_gov'
        AND table_name = 'transaction_rule_matches'
        AND grantee = current_user
        AND privilege_type = 'SELECT'
    ) THEN
        GRANT SELECT, INSERT, UPDATE, DELETE ON fraud_gov.transaction_rule_matches TO fraud_gov_app_user;
    END IF;

    -- Grant SELECT, INSERT, UPDATE, DELETE on transaction_reviews table
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.role_table_grants
        WHERE table_schema = 'fraud_gov'
        AND table_name = 'transaction_reviews'
        AND grantee = current_user
        AND privilege_type = 'SELECT'
    ) THEN
        GRANT SELECT, INSERT, UPDATE, DELETE ON fraud_gov.transaction_reviews TO fraud_gov_app_user;
    END IF;

    -- Grant SELECT, INSERT, UPDATE, DELETE on analyst_notes table
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.role_table_grants
        WHERE table_schema = 'fraud_gov'
        AND table_name = 'analyst_notes'
        AND grantee = current_user
        AND privilege_type = 'SELECT'
    ) THEN
        GRANT SELECT, INSERT, UPDATE, DELETE ON analyst_notes TO fraud_gov_app_user;
    END IF;

    -- Grant SELECT, INSERT, UPDATE, DELETE on transaction_cases table
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.role_table_grants
        WHERE table_schema = 'fraud_gov'
        AND table_name = 'transaction_cases'
        AND grantee = current_user
        AND privilege_type = 'SELECT'
    ) THEN
        GRANT SELECT, INSERT, UPDATE, DELETE ON transaction_cases TO fraud_gov_app_user;
    END IF;

    -- Grant SELECT, INSERT, UPDATE, DELETE on case_activity_log table
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.role_table_grants
        WHERE table_schema = 'fraud_gov'
        AND table_name = 'case_activity_log'
        AND grantee = current_user
        AND privilege_type = 'SELECT'
    ) THEN
        GRANT SELECT, INSERT, UPDATE, DELETE ON case_activity_log TO fraud_gov_app_user;
    END IF;

    -- Grant USAGE on sequences for SERIAL columns
    GRANT USAGE ON ALL SEQUENCES IN SCHEMA fraud_gov TO fraud_gov_app_user;

    -- Grant future sequences as well
    ALTER DEFAULT PRIVILEGES IN SCHEMA fraud_gov GRANT USAGE ON SEQUENCES TO fraud_gov_app_user;

    -- Grant usage on case_number_seq
    GRANT USAGE ON fraud_gov.case_number_seq TO fraud_gov_app_user;

EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Grant permissions may have failed, user may not exist yet: %', SQLERRM;
END $$;

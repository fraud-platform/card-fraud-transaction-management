# Testing Strategy

**Reference:** See [technical-design/00-comprehensive-technical-design.md](../02-development/architecture.md), Section 9 for detailed testing strategy.

This document provides a quick reference for test implementation and common patterns.

## Test Layers

| Layer | Focus | Tools |
|-------|-------|-------|
| Unit | Event validation, idempotency logic, service logic | pytest, Pydantic |
| Integration (DB) | Persist behavior, transactions | pytest, asyncpg |
| Integration (Kafka) | Consumer behavior, DLQ | pytest, kafka-python |
| Smoke | Basic API happy paths with real DB | pytest, httpx ASGI transport |
| E2E Integration | Full workflows across endpoints | pytest, httpx ASGI transport |
| Contract | Schema validation | jsonschema, fastjsonschema, ajv |
| Performance | Throughput, latency | k6, locust |

### Test Markers

```bash
# Unit tests (fast, no DB required)
uv run pytest -m unit

# Integration tests (real DB)
uv run doppler-local-test -m integration

# Smoke tests (basic happy paths)
uv run doppler-local-test -m smoke

# E2E Integration tests (full workflows)
uv run doppler run -- pytest -m e2e_integration

# All tests
uv run doppler-local-test
```

## Key Test Scenarios

### Unit Tests

- Event validation against JSON Schema v1
- Idempotency policy functions (upsert/no-op decisions)
- PAN detection logic
- Card identifier mode enforcement

### Integration Tests (Database)

- Single event: inserts 1 transaction + N rule matches
- Duplicate event: does not create duplicates
- Partial failure: does not leave orphan rule matches

### Integration Tests (Kafka)

- Consume messages and commit offsets after DB commit
- Poison message routes to DLQ
- Circuit breaker behavior

### Contract Tests

- Lock the decision event schema: required fields + enum values
- Ensure tolerance for additional fields (forward-compatible parsing)
- Validate JSON Schema with multiple validators:
  - Python: `jsonschema`, `fastjsonschema`
  - JS: `ajv`

### Performance Tests

- Ingestion throughput target (TBD)
- Query performance on time ranges

## Test Data Fixtures

| Fixture | Purpose |
|---------|---------|
| APPROVE decision | Positive case |
| DECLINE decision | Negative case |
| POSTAUTH with null decision | Edge case |
| Empty matched_rules | Minimal payload |
| Large matched_rules arrays | Performance test |

## Running Tests

```bash
# Run all tests (requires Doppler secrets)
uv run doppler-local-test  # Local Docker DB
uv run doppler-test        # Neon test branch
uv run doppler-prod        # Neon prod branch

# Unit tests only (fast, no Doppler required)
uv run pytest tests/unit -v --no-cov

# With coverage
uv run pytest --cov=app --cov-report=term-missing

# Run specific test category
uv run pytest tests/unit/
uv run pytest tests/integration/
uv run pytest tests/contract/
```

## Important Testing Patterns

### 0. Understanding Transaction IDs (Critical for Tests)

The `transactions` table has **TWO UUID columns** with different purposes:

| Column | Purpose | Source |
|--------|---------|--------|
| `id` | Surrogate primary key (identifies the database row) | Generated by Transaction Management app |
| `transaction_id` | Business transaction ID (for idempotency/lookups) | From Rule Engine |

**Child Table FK Pattern:**
```sql
-- transaction_reviews.transaction_id REFERENCES transactions(id)
-- NOT: transaction_reviews.transaction_id REFERENCES transactions.transaction_id
```

**Correct JOIN Pattern:**
```sql
-- CORRECT
FROM transaction_reviews r
JOIN transactions t ON r.transaction_id = t.id  -- r.transaction_id references t.id

-- WRONG
FROM transaction_reviews r
JOIN transactions t ON r.transaction_id = t.transaction_id
```

**In Tests:**
- When inserting test data, provide both `id` (PK) and `transaction_id` (business key)
- When querying, be explicit about which ID you're using
- See `db/fraud_transactions_schema.sql` header for full explanation

### 1. Repository.list() Return Value Order

The `TransactionRepository.list()` method returns a 3-tuple in this specific order:

```python
# CORRECT unpacking order
items, next_cursor, total = await repo.list(
    card_id="tok_visa",
    decision="DECLINE",
    limit=10,
)

# WRONG - this will assign next_cursor to the total variable
items, total, next_cursor = await repo.list(...)  # DON'T DO THIS
```

**Return type:** `tuple[list[dict[str, Any]], str | None, int]`

### 2. Rule Match Required Fields

When inserting rule matches, the database schema requires `rule_name`:

```python
# CORRECT - includes all required fields
rule_data = {
    "rule_id": str(uuid7()),
    "rule_version": 1,
    "rule_name": "Test Rule",  # REQUIRED - NOT NULL in database
}

# WRONG - will violate NOT NULL constraint
rule_data = {
    "rule_id": str(uuid7()),
    "rule_version": 1,
}
```

### 3. Async HTTP Client in Tests

The auth module uses a shared async HTTP client for JWKS fetching. In tests:

```python
from app.core.auth import get_async_http_client, close_async_http_client

# The client automatically handles closed event loops
client = get_async_http_client()  # Safe - checks is_closed internally

# Cleanup is optional but recommended in test teardown
await close_async_http_client()  # Safe - handles RuntimeError
```

### 4. Domain Error Exception Handling

Domain errors (subclasses of `TransactionManagementError`) are automatically converted to appropriate HTTP status codes:

```python
from app.core.errors import UnauthorizedError, ValidationError, NotFoundError

# These are automatically mapped to HTTP status codes:
# UnauthorizedError → 401
# ValidationError → 400
# NotFoundError → 404
# ForbiddenError → 403
# ConflictError → 409
# PCIComplianceError → 422

raise UnauthorizedError("Invalid token")  # Returns 401 response
```

### 5. Authentication Test Pattern

When testing authenticated endpoints with an invalid token:

```python
async def test_reject_invalid_token(self, client_app_no_auth):
    """Test that invalid tokens are rejected."""
    transport = httpx.ASGITransport(app=client_app_no_auth)
    async with httpx.AsyncClient(transport=transport, base_url="http://test") as client:
        response = await client.get(
            "/v1/transactions",
            headers={"Authorization": "Bearer invalid_token_here"},
        )
        # Returns 401 due to domain_error_handler in main.py
        assert response.status_code == 401
```

The `client_app_no_auth` fixture creates an app WITHOUT authentication override, ensuring real auth is tested.

## Common Test Issues

### Issue: "Event loop is closed" error

**Symptoms:** Tests fail with `RuntimeError: Event loop is closed`

**Cause:** The async HTTP client is shared across tests and gets closed during cleanup.

**Solution:** The `get_async_http_client()` function now handles this automatically by checking `is_closed` and recreating the client if needed.

### Issue: NOT NULL constraint violation on rule_name

**Symptoms:** `asyncpg.exceptions.NotNullViolationError: null value in column "rule_name"`

**Cause:** Rule match test data doesn't include `rule_name`.

**Solution:** Always provide `rule_name` when inserting rule matches.

### Issue: Test unpacking asserts None for expected int

**Symptoms:** `assert isinstance(total, int)` fails because `total` is `None`

**Cause:** Wrong unpacking order for `repo.list()` return value.

**Solution:** Use `items, next_cursor, total = await repo.list(...)` order.

### E2E Integration Tests

E2E tests verify complete workflows across multiple API endpoints with real database connections.

**Coverage (61 tests):**
- **Reviews** (9): get/create, status updates, assign, resolve, escalate, full lifecycle
- **Notes** (8): CRUD, visibility, note types, validation
- **Cases** (13): create, update, add/remove transactions, activity log, resolve
- **Worklist** (12): get with filters, stats, claim next transaction
- **Bulk Operations** (11): assign, status update, create case
- **Full Workflows** (6): fraud investigation, escalation, case lifecycle, pagination

**Key Differences:**
- Unit tests mock dependencies → can't catch integration bugs
- E2E tests use real DB + HTTP → catch SQL JOIN bugs, response mapping issues, serialization problems

**Running E2E tests:**
```bash
# Requires Doppler for DATABASE_URL_APP
uv run doppler run -- pytest -m e2e_integration

# Or run specific E2E test file
uv run doppler run -- pytest tests/e2e/test_reviews_e2e.py -v
```

**Bugs Found by E2E Tests (that unit tests missed):**
- SQL JOIN bugs: `r.transaction_id = t.transaction_id` → `r.transaction_id = t.id` ✅ FIXED
- Response mapping: `id` vs `review_id` mismatches in worklist items ✅ FIXED
- Missing fields: `resolved_by_code`, `decision_reason` not in stats/response ✅ FIXED
- UUID serialization: JSON encoding errors in activity logs ✅ FIXED
- Status transitions: IN_REVIEW → IN_REVIEW validation edge case ✅ FIXED
- Dead code in case_repository.py (unreachable return statement) ✅ FIXED

## Unit Test Enhancements (2026-01-29)

After E2E tests caught 11 integration bugs that unit tests missed, we enhanced unit test coverage to catch these issues earlier.

**New Test Files:**
| File | Purpose | Tests |
|------|---------|-------|
| `test_transaction_repository_sql.py` | SQL inspection for JOIN patterns | 14 |
| `test_review_repository_field_mapping.py` | Field mapping verification | 12 |
| `test_worklist_service_edge_cases.py` | Edge cases (empty, None, invalid) | 8 |
| `test_case_repository_serialization.py` | UUID/JSONB serialization | 4 |
| `test_cursor_pagination.py` | Cursor behavior & encode/decode | 14 |
| `test_response_schema_validation.py` | Pydantic schema validation | 9 |
| `test_api_smoke_expanded.py` | Expanded endpoint coverage | 30+ |
| `tests/utils/schema_validators.py` | Reusable test helpers | - |

**Key Learnings:**

1. **SQL Inspection Tests**: Use `inspect.getsource()` to verify actual SQL patterns in code
   - Catch JOIN bugs at test time instead of E2E
   - Verify FK relationships use PK (`id`) not business key (`transaction_id`)

2. **Field Mapping Tests**: Verify `_row_to_dict_full()` maps columns correctly
   - Mock database rows with proper `__getitem__` and `__len__` implementations
   - Verify required fields like `review_id` (not `id`) and `decision_reason` are present

3. **Edge Case Tests**: Test empty results, None returns, invalid inputs
   - Repository methods return `None` for not-found (don't raise)
   - Empty lists returned when no unassigned items exist
   - Invalid cursors handled gracefully (return empty list)

4. **Schema Validation Tests**: Verify responses match Pydantic schemas
   - Use `validate_response_schema()` helper
   - Check required fields are present
   - Test both valid and invalid data

5. **Smoke Tests**: Verify endpoints respond (not that they work correctly)
   - Use random UUIDs → expect 4xx/5xx status codes
   - Skip tests that require existing data with `@pytest.mark.skip`
   - Focus on endpoint routing, not functional correctness


## TODO

- [ ] Decide test framework stack by language
- [ ] Decide how to run ephemeral Postgres in CI
- [ ] Define golden fixtures and schema validation tests
- [ ] Define basic load test scenario and success criteria

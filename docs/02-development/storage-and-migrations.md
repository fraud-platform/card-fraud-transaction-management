# Storage & Migrations Plan

## Storage choice
Recommended: **PostgreSQL** (due to JSONB support + strong upsert semantics).

Environment notes:
- Local: PostgreSQL via local Docker (aligned with existing rule-management local setup).
- Test/prod: PostgreSQL via Neon (use dedicated branches per environment).

Rationale:
- `raw_payload JSONB` is explicitly in the schema.
- Supports `INSERT ... ON CONFLICT` for idempotency.

## Schema (MVP — locked)
Two tables only:
- `transactions`
- `transaction_rule_matches`

(Exact column set should match the authoritative doc.)

## Constraints and keys
- `transactions.id` is PK (UUID v7, surrogate key generated by Transaction Management app)
- `transactions.transaction_id` is the business key from Rule Engine (UUID v7)
- Unique constraint: `(transaction_id, evaluation_type, transaction_timestamp)` for idempotency
- `transaction_rule_matches.transaction_id` FK references `transactions(id)` — NOT `transactions.transaction_id`

**IMPORTANT:** Child tables (transaction_reviews, transaction_rule_matches, etc.) have `transaction_id` columns that reference `transactions(id)`, NOT `transactions(transaction_id)`. See schema file header for detailed explanation.

Planned `transactions` columns beyond the original minimum:
- `card_id` (tokenized, NOT NULL)
- `card_last4` (nullable)
- `card_network` (nullable)
- `mcc` (nullable)
- `ip` (nullable)
- `decision_reason` (nullable for POSTAUTH)
- `produced_at` (NOT NULL)
- `ingestion_source` (NOT NULL)
- `updated_at` (NOT NULL)

Planned `transaction_rule_matches` columns beyond the original minimum:
- `priority` (nullable)

Idempotency needs a deterministic conflict target for rule matches. Options:
1. **Add a UNIQUE CONSTRAINT** on `(transaction_id, rule_id, rule_version)` (required). (Not a new table; aligns to “idempotent insert”.)

## Index plan (aligned to query targets)
Only add indexes that support Section 9 patterns. Candidate indexes:
- `transactions (transaction_timestamp)` for time scans.
- `transactions (decision, transaction_timestamp)` for declined-over-time.
- `transactions (merchant_id, transaction_timestamp)` for merchant trends.
- `transactions (card_id, transaction_timestamp)` for card activity.
- `transaction_rule_matches (rule_id, evaluated_at)` for rule effectiveness.
- `transaction_rule_matches (transaction_id)` for joins.

## Migrations strategy
- Use a migrations tool appropriate to the chosen framework (Flyway/Liquibase/DbUp/Prisma migrations/Alembic).
- Migrations must be:
  - deterministic
  - environment-safe
  - run automatically in CI for validation
  - run at deploy time with clear rollback guidance

## Transaction boundaries
Ingestion persistence should be **one DB transaction**:
1. Upsert `transactions`.
2. Insert/upsert `transaction_rule_matches`.
3. Commit.

This enforces ordering/atomicity.

## raw_payload policy (locked)
- Allowed in prod **only** as an allowlist-only, redacted JSON object.
- Never store full PAN/CVV/expiry or other sensitive card data.
- Recommend storing only the minimum needed for replay/debugging, e.g. `merchant_id`, `amount`, `currency`, `country`, `mcc`.

## Throughput considerations
- Batch inserts for rule matches per event.
- Use prepared statements.
- Consider partitioning later (see retention/archival plan).

## TODO checklist
- Confirm Postgres version target (e.g., 15+).
- Decide whether to enforce FK constraint (optional by spec).
- Ensure unique constraint for rule matches idempotency is created in migrations.
- Define migrations execution in deployment pipeline.
